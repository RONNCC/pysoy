/* soy.vapi generated by valac-0.18 0.18.1, do not modify. */

namespace soy {
	namespace atoms {
		[CCode (cheader_filename = "soy.h")]
		public class Area : GLib.Object {
			public Area (float x1, float y1, float x2, float y2);
			public new void @set (float x1, float y1, float x2, float y2);
			public float x1 { get; set; }
			public float x2 { get; set; }
			public float y1 { get; set; }
			public float y2 { get; set; }
			public signal void on_set (soy.atoms.Area area);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Axis : GLib.Object {
			public Axis (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public Axis.normalize (soy.atoms.Axis axis);
			public new void @set (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public float x { get; set; }
			public float y { get; set; }
			public float z { get; set; }
			public signal void on_set (soy.atoms.Axis vector);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Color : GLib.Object {
			public class Colormap : Gee.HashMap<global::string,uint> {
				public Colormap ();
				public static bool check_type (GLib.Object v);
				public soy.atoms.Color? get_color (global::string key);
				public uint get_color_uint (global::string key);
				public void set_color (global::string key, soy.atoms.Color v);
				public void set_color_uint (global::string key, uint v);
			}
			public Color (uchar red, uchar green, uchar blue, uchar alpha = 255);
			public Color.add (soy.atoms.Color a, soy.atoms.Color b);
			public static bool cmp (GLib.Object left, GLib.Object right, soy.Comparison comparison);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public Color.divide (soy.atoms.Color a, soy.atoms.Color b);
			public float[] get4f ();
			public uchar[] get4ub ();
			public Color.load (global::string packet);
			public Color.multiply (soy.atoms.Color a, soy.atoms.Color b);
			public Color.named (global::string color);
			public Color.new4f (float[] rgba);
			public Color.new4ub (uchar[] rgba);
			public global::string string ();
			public Color.subtract (soy.atoms.Color a, soy.atoms.Color b);
			public uchar alpha { get; set; }
			public uchar blue { get; set; }
			public uchar green { get; set; }
			public global::string hex { owned get; set; }
			public uchar luma { get; set; }
			public static soy.atoms.Color.Colormap names { get; }
			public uchar red { get; set; }
			public signal void on_set (soy.atoms.Color color);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Face : GLib.Object {
			public Face (soy.atoms.Vertex a, soy.atoms.Vertex b, soy.atoms.Vertex c);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public new soy.atoms.Vertex? @get (int index);
			public new void @set (int index, soy.atoms.Vertex value);
			public Face.with_material (soy.atoms.Vertex a, soy.atoms.Vertex b, soy.atoms.Vertex c, soy.materials.Material material);
			public soy.materials.Material material { get; set; }
			public signal void on_set (soy.atoms.Face face);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Morph : GLib.Object {
			public Morph (soy.bodies.Mesh a, soy.bodies.Mesh b);
			public Morph.with_delta (soy.bodies.Mesh a, soy.bodies.Mesh b, float delta);
			public float delta { get; set; }
			public GL.GLfloat* matrix { get; }
			public signal void on_set (soy.atoms.Morph morph);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Position : GLib.Object {
			public Position (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public new void @set (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public float x { get; set; }
			public float y { get; set; }
			public float z { get; set; }
			public signal void on_set (soy.atoms.Position position);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Radius : GLib.Object {
			public Radius (float length = 0.0f);
			public new void @set (float length = 0.0f);
			public float length { get; set; }
			public signal void on_set (soy.atoms.Radius radius);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Rotation : GLib.Object {
			public Rotation (float alpha = 0.0f, float beta = 0.0f, float gamma = 0.0f);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public new void @set (float alpha = 0.0f, float beta = 0.0f, float gamma = 0.0f);
			public float alpha { get; set; }
			public float beta { get; set; }
			public float gamma { get; set; }
			public signal void on_set (soy.atoms.Rotation Rotation);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Size : GLib.Object {
			public Size (float width = 0.0f, float height = 0.0f, float depth = 0.0f);
			public new void @set (float width = 0.0f, float height = 0.0f, float depth = 0.0f);
			public float depth { get; set; }
			public float height { get; set; }
			public float width { get; set; }
			public signal void on_set (soy.atoms.Size size);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Vector : GLib.Object {
			public Vector (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public new void @set (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public float x { get; set; }
			public float y { get; set; }
			public float z { get; set; }
			public signal void on_set (soy.atoms.Vector vector);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Vertex : GLib.Object {
			public Vertex (soy.atoms.Position position, soy.atoms.Vector normal, soy.atoms.Position texcoord, soy.atoms.Vector tangent);
			public static bool cmp_eq (GLib.Object left, GLib.Object right);
			public static bool cmp_ne (GLib.Object left, GLib.Object right);
			public soy.atoms.Vector normal { owned get; set; }
			public soy.atoms.Position position { owned get; set; }
			public soy.atoms.Vector tangent { owned get; set; }
			public soy.atoms.Position texcoord { owned get; set; }
			public signal void on_set (soy.atoms.Vertex vertex);
		}
	}
	namespace bodies {
		[CCode (cheader_filename = "soy.h")]
		public class Body : GLib.Object {
			public ode.Body? body;
			public ode.geoms.Geom geom;
			public string key;
			public GLib.Mutex mutex;
			public soy.scenes.Scene? scene;
			public Gee.HashMap<string,float?> tags_;
			public Body (soy.atoms.Position? position, GLib.Object? geom_param, float geom_scalar);
			public void add (string k, soy.scenes.Scene v);
			public void addForce (ode.Real fx, ode.Real fy, ode.Real fz);
			public void addForceAtPos (ode.Real fx, ode.Real fy, ode.Real fz, ode.Real px, ode.Real py, ode.Real pz);
			public void addForceAtRelPos (ode.Real fx, ode.Real fy, ode.Real fz, ode.Real px, ode.Real py, ode.Real pz);
			public void addRelForce (ode.Real fx, ode.Real fy, ode.Real fz);
			public void addRelForceAtPos (ode.Real fx, ode.Real fy, ode.Real fz, ode.Real px, ode.Real py, ode.Real pz);
			public void addRelForceRelAtPos (ode.Real fx, ode.Real fy, ode.Real fz, ode.Real px, ode.Real py, ode.Real pz);
			public void addRelTorque (ode.Real fx, ode.Real fy, ode.Real fz);
			public void addTorque (ode.Real fx, ode.Real fy, ode.Real fz);
			public virtual void add_extra ();
			public virtual void calcFogCoords (float _depth);
			public virtual void create_geom (GLib.Object? geom_param, float geom_scalar);
			public virtual int finite ();
			public float[] getPositionf ();
			public virtual void mult_model_matrix ();
			public virtual float pointDepth (float x, float y, float z);
			public void remove ();
			public virtual void remove_extra ();
			public virtual void render ();
			public void toggle_immovable ();
			public virtual float volume ();
			public soy.Mass mass { get; }
			public soy.atoms.Position position { owned get; set; }
			public soy.atoms.Rotation rotation { owned get; set; }
			public Gee.HashMap<string,float?> tags { owned get; }
			public soy.atoms.Vector velocity { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Box : soy.bodies.Body {
			public Box (soy.atoms.Position? position, soy.atoms.Size? size, soy.materials.Material? material);
			public override void create_geom (GLib.Object? geom_param, float geom_scalar);
			public override float pointDepth (float x, float y, float z);
			public override void render ();
			public override float volume ();
			public soy.materials.Material material { get; set; }
			public soy.atoms.Size size { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Camera : soy.bodies.Body {
			public Camera (soy.atoms.Position? position);
			public void project (GL.GLfloat aspect);
			public float lens { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Light : soy.bodies.Body {
			public GL.GLuint VERTICES;
			public Light (soy.atoms.Position? position);
			public override void add_extra ();
			public void off (GL.GLenum id);
			public void on (GL.GLenum id);
			public override void remove_extra ();
			public override void render ();
			public soy.atoms.Color ambient { owned get; set; }
			public soy.atoms.Color diffuse { owned get; set; }
			public float radius { get; set; }
			public float size { get; set; }
			public soy.atoms.Color specular { owned get; set; }
			public soy.textures.Texture texture { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Mesh : soy.bodies.Body {
			public Mesh (soy.atoms.Position? position);
			public soy.bodies.Mesh clone ();
			public new soy.atoms.Face? @get (int index);
			public GL.GLfloat* get_raw_verts ();
			public soy.atoms.Morph morph (soy.bodies.Mesh variant, float delta);
			public override void render ();
			public new void @set (int index, GLib.Object value);
			public void set_raw_verts (GL.GLfloat* verts);
			public int length { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Sphere : soy.bodies.Body {
			public Sphere (soy.atoms.Position? position, float radius, soy.materials.Material? material);
			public override void create_geom (GLib.Object? geom_param, float geom_scalar);
			public override void render ();
			public override float volume ();
			public soy.materials.Material material { get; set; }
			public float radius { get; set; }
			public uint subdivisions { get; set; }
		}
	}
	namespace controllers {
		namespace graph {
			namespace _grid {
				[CCode (cheader_filename = "soy.h")]
				public class IntNode : GLib.Object, soy.controllers.graph.INode {
					public IntNode (soy.controllers.graph.Grid graph, soy.atoms.Position pos);
					public virtual void add_connection (soy.controllers.graph.INode other);
					public virtual Gee.List<soy.controllers.graph.Edge> get_edges ();
					public virtual uint hash ();
					public IntNode.with_OffsetPair (soy.controllers.graph.Grid graph, soy.controllers.graph._grid.OffsetPair offset);
					public IntNode.with_int_offset (soy.controllers.graph.Grid graph, int x_offset, int y_offset);
					public int x { get; }
					public int y { get; }
				}
				[CCode (cheader_filename = "soy.h")]
				public class OffsetPair : GLib.Object {
					public int x;
					public int y;
					public OffsetPair (int x, int y);
					public uint hash ();
					public static int offset_hash (int x, int y);
				}
				[CCode (cheader_filename = "soy.h")]
				public class TerminalNode : GLib.Object, soy.controllers.graph.INode {
					public TerminalNode (soy.controllers.graph.Grid graph, soy.atoms.Position pos, soy.controllers.graph._grid.OffsetPair[] connected);
					public virtual void add_connection (soy.controllers.graph.INode other);
					public virtual Gee.List<soy.controllers.graph.Edge> get_edges ();
				}
			}
			namespace _space {
				[CCode (cheader_filename = "soy.h")]
				public class Int3Node : GLib.Object, soy.controllers.graph.INode {
					public Int3Node (soy.controllers.graph.Space graph, soy.atoms.Position pos);
					public virtual void add_connection (soy.controllers.graph.INode other);
					public virtual Gee.List<soy.controllers.graph.Edge> get_edges ();
					public virtual uint hash ();
					public Int3Node.with_OffsetTriple (soy.controllers.graph.Space graph, soy.controllers.graph._space.OffsetTriple offset);
					public Int3Node.with_int_offset (soy.controllers.graph.Space graph, int x_offset, int y_offset, int z_offset);
					public int x { get; }
					public int y { get; }
					public int z { get; }
				}
				[CCode (cheader_filename = "soy.h")]
				public class OffsetTriple : GLib.Object {
					public int x;
					public int y;
					public int z;
					public OffsetTriple (int x, int y, int z);
					public int hash ();
					public static int offset_hash (int x, int y, int z);
				}
				[CCode (cheader_filename = "soy.h")]
				public class TerminalNode : GLib.Object, soy.controllers.graph.INode {
					public TerminalNode (soy.controllers.graph.Space graph, soy.atoms.Position pos, soy.controllers.graph._space.OffsetTriple[] connected);
					public virtual void add_connection (soy.controllers.graph.INode other);
					public virtual Gee.List<soy.controllers.graph.Edge> get_edges ();
				}
			}
			[CCode (cheader_filename = "soy.h")]
			public class AbstractGraph : GLib.Object {
				public AbstractGraph (soy.scenes.Scene scene, float radius = -1.0f, soy.atoms.Size? size = null);
				public virtual bool[] check_collisions (soy.atoms.Position start, soy.atoms.Position[] ends);
				public float radius { get; }
				public soy.scenes.Scene scene { get; }
				public soy.atoms.Size? size { get; }
			}
			[CCode (cheader_filename = "soy.h")]
			public class Edge {
				public weak soy.controllers.graph.INode begin;
				public float distance;
				public weak soy.controllers.graph.INode end;
				public float total_cost;
				public Edge (float dist, soy.controllers.graph.INode begin, soy.controllers.graph.INode end);
			}
			[CCode (cheader_filename = "soy.h")]
			public class Grid : soy.controllers.graph.AbstractGraph, soy.controllers.graph.IGraph {
				public Grid (soy.scenes.Scene scene, float granularity, soy.atoms.Position? center = null);
				public Grid._default (soy.scenes.Scene scene, float granularity, float radius, soy.atoms.Size? size, soy.atoms.Position? center);
				public virtual soy.controllers.graph.INode add_terminal_node (soy.atoms.Position pos);
				public soy.controllers.graph._grid.OffsetPair convert_to_offset (soy.atoms.Position pos);
				public soy.controllers.graph._grid.IntNode get_node_with_offset (int x_offset, int y_offset);
				public Grid.with_radius (soy.scenes.Scene scene, float granularity, float radius, soy.atoms.Position? center = null);
				public Grid.with_size (soy.scenes.Scene scene, float granularity, soy.atoms.Size size, soy.atoms.Position? center = null);
				public soy.atoms.Position center { get; }
				public float granularity { get; }
			}
			[CCode (cheader_filename = "soy.h")]
			public class Pathfinder : GLib.Object {
				public Pathfinder (soy.scenes.Scene scene, soy.atoms.Position start, soy.atoms.Position end, soy.controllers.graph.IGraph graph);
				public soy.controllers.graph.INode find_closest ();
				public static Gee.List<soy.atoms.Position> find_optimized_path (soy.scenes.Scene scene, soy.atoms.Position begin, soy.atoms.Position end, soy.controllers.graph.IGraph graph);
				public static Gee.List<soy.atoms.Position> find_path (soy.scenes.Scene scene, soy.atoms.Position begin, soy.atoms.Position end);
				public static Gee.List<soy.atoms.Position> find_path_with_graph (soy.scenes.Scene scene, soy.atoms.Position begin, soy.atoms.Position end, soy.controllers.graph.IGraph graph);
				public Gee.List<soy.atoms.Position> get_optimized_path ();
				public Gee.List<soy.atoms.Position> get_path ();
				public string tp_repr ();
			}
			[CCode (cheader_filename = "soy.h")]
			public class Space : soy.controllers.graph.AbstractGraph, soy.controllers.graph.IGraph {
				public Space (soy.scenes.Scene scene, float granularity, soy.atoms.Position? center = null);
				public Space._default (soy.scenes.Scene scene, float granularity, float radius, soy.atoms.Size? size, soy.atoms.Position? center);
				public virtual soy.controllers.graph.INode add_terminal_node (soy.atoms.Position pos);
				public soy.controllers.graph._space.OffsetTriple convert_to_offset (soy.atoms.Position pos);
				public soy.controllers.graph._space.Int3Node get_node_with_offset (int x_offset, int y_offset, int z_offset);
				public Space.with_radius (soy.scenes.Scene scene, float granularity, float radius, soy.atoms.Position? center = null);
				public Space.with_size (soy.scenes.Scene scene, float granularity, soy.atoms.Size size, soy.atoms.Position? center = null);
				public soy.atoms.Position center { get; }
				public float granularity { get; }
			}
			[CCode (cheader_filename = "soy.h")]
			public interface IGraph : GLib.Object {
				public abstract soy.controllers.graph.INode add_terminal_node (soy.atoms.Position pos);
				public abstract bool[] check_collisions (soy.atoms.Position start, soy.atoms.Position[] ends);
				public abstract soy.controllers.graph.INode get_node (soy.atoms.Position pos);
			}
			[CCode (cheader_filename = "soy.h")]
			public interface INode : GLib.Object {
				public abstract Gee.List<soy.controllers.graph.Edge> get_edges ();
				public abstract soy.atoms.Position position { get; }
			}
		}
		[CCode (cheader_filename = "soy.h")]
		public class BaseNavigator : soy.controllers.Pathfollower {
			public soy.controllers.graph.IGraph graph;
			public GLib.TimeoutSource? source;
			public BaseNavigator (soy.scenes.Scene scene, soy.bodies.Body controlled, float speed, float fuzziness, soy.controllers.graph.IGraph graph, soy.atoms.Position end, bool updates, bool paused);
			public override void path_finished (ode.Body body);
			public override void skipped (ode.Body body);
			public void update_path ();
			public override void waypoint_reached (ode.Body body, soy.atoms.Vector next_vec, float dist);
			public soy.atoms.Position destination { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Controller : GLib.Object {
			public Controller ();
			public virtual string tp_repr ();
		}
		[CCode (cheader_filename = "soy.h")]
		public class Dualshock3 : soy.controllers.Controller {
			public Dualshock3 ();
			public void show_master ();
			public override string tp_repr ();
		}
		[CCode (cheader_filename = "soy.h")]
		public class GridNavigator : soy.controllers.BaseNavigator {
			public GridNavigator (soy.scenes.Scene scene, soy.bodies.Body controlled, float speed, float fuzziness, float granularity, soy.atoms.Position end, bool updates, bool paused);
			public GridNavigator.with_graph (soy.scenes.Scene scene, soy.bodies.Body controlled, float speed, float fuzziness, soy.controllers.graph.IGraph graph, soy.atoms.Position end, bool updates, bool paused);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Keyboard : soy.controllers.Controller {
			public Keyboard ();
			public override string tp_repr ();
			public signal void key_press (soy.events.KeyPress e);
			public signal void key_release (soy.events.KeyRelease e);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Pathfollower : soy.controllers.VirtualController {
			public soy.bodies.Body controlled;
			public GLib.RecMutex path_lock;
			public GLib.Mutex pause_lock;
			public Pathfollower (soy.scenes.Scene scene, soy.bodies.Body controlled, float speed, float fuzziness, bool paused, Gee.Iterable<soy.atoms.Position> path);
			public virtual void between_waypoints (ode.Body body, soy.atoms.Vector next_vec, float dist);
			public virtual void path_finished (ode.Body body);
			public override void run_controller ();
			public virtual void skipped (ode.Body body);
			public override string tp_repr ();
			public override void unregister_controller ();
			public virtual void waypoint_reached (ode.Body body, soy.atoms.Vector next_vec, float dist);
			public override bool finished { get; }
			public float fuzziness { get; set; }
			public Gee.Iterable<soy.atoms.Position> path { get; set; }
			public bool paused { get; set; }
			public virtual float speed { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Pointer : soy.controllers.Controller {
			public Pointer ();
			public void motion (int x, int y);
			public override string tp_repr ();
			public soy.atoms.Position position { owned get; set; }
			public signal void button_press (soy.events.ButtonPress e);
			public signal void button_release (soy.events.ButtonRelease e);
		}
		[CCode (cheader_filename = "soy.h")]
		public class SpaceNavigator : soy.controllers.BaseNavigator {
			public SpaceNavigator (soy.scenes.Scene scene, soy.bodies.Body controlled, float speed, float fuzziness, float granularity, soy.atoms.Position end, bool updates, bool paused);
			public SpaceNavigator.with_graph (soy.scenes.Scene scene, soy.bodies.Body controlled, float speed, float fuzziness, soy.controllers.graph.IGraph graph, soy.atoms.Position end, bool updates, bool paused);
		}
		[CCode (cheader_filename = "soy.h")]
		public class VirtualController : soy.controllers.Controller {
			public soy.scenes.Scene scene;
			public VirtualController (soy.scenes.Scene scene);
			public virtual void register_controller ();
			public virtual void run_controller ();
			public new string tp_repr ();
			public virtual void unregister_controller ();
			public virtual bool finished { get; }
			public virtual bool registered { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Wiimote : soy.controllers.Controller {
			public Wiimote ();
			public uint8 toggle_bit (uint8 bf, uint8 b);
			public signal void wiimote_button_press (soy.events.Wiibutton e);
		}
	}
	namespace events {
		[CCode (cheader_filename = "soy.h")]
		public class ButtonPress : soy.events.Device {
			public ButtonPress ();
			public int button { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class ButtonRelease : soy.events.Device {
			public ButtonRelease ();
			public int button { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Device : soy.events.Event {
			public int detail;
			public Device ();
			public Device.instance (int detail, double root_x, double root_y, double x, double y);
			public double root_x { get; }
			public double root_y { get; }
			public double x { get; }
			public double y { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Event : GLib.Object {
			public Event ();
		}
		[CCode (cheader_filename = "soy.h")]
		public class KeyPress : soy.events.Device {
			public KeyPress ();
			public int key { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class KeyRelease : soy.events.Device {
			public KeyRelease ();
			public int key { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public struct Button {
			public soy.EventType type;
			public soy.widgets.Window window;
			public uint32 time;
			public float x;
			public float y;
			public float x_root;
			public float y_root;
			public uint button;
			public string wiibutton;
		}
		[CCode (cheader_filename = "soy.h")]
		public struct Motion {
			public soy.EventType type;
			public soy.widgets.Window window;
			public uint32 time;
			public float x;
			public float y;
			public float x_root;
			public float y_root;
		}
		[CCode (cheader_filename = "soy.h")]
		public struct Scroll {
			public soy.EventType type;
			public soy.widgets.Window window;
			public uint32 time;
			public float x;
			public float y;
			public float x_root;
			public float y_root;
			public soy.ScrollDirection direction;
		}
		[CCode (cheader_filename = "soy.h")]
		public struct Wiibutton {
			public soy.EventType type;
			public uint16 wiibutton;
		}
	}
	namespace fields {
		[CCode (cheader_filename = "soy.h")]
		public class Accelerate : soy.fields.Field {
			public Accelerate (float x = 0.0f, float y = 0.0f, float z = 0.0f);
			public override void commit ();
			public override bool exert (soy.bodies.Body other);
			public soy.atoms.Vector acceleration { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Buoyancy : soy.fields.Field {
			public Buoyancy ();
			public override bool exert (soy.bodies.Body other);
			public override void give (int data);
			public float density { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Field : soy.bodies.Body {
			public Field ();
			public bool apply ();
			public virtual void commit ();
			public virtual bool exert (soy.bodies.Body other);
			public virtual void give (int data);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Monopole : soy.fields.Field {
			public Monopole ();
			public override void commit ();
			public override bool exert (soy.bodies.Body other);
			public float multiplier { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Shockwave : soy.fields.Field {
			public Shockwave ();
			public void activate ();
			public override bool exert (soy.bodies.Body other);
			public override void give (int data);
			public float energy { get; set; }
			public float length { get; set; }
			public float radius { get; set; }
			public float swvel { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Wind : soy.fields.Field {
			public Wind ();
			public override bool exert (soy.bodies.Body other);
			public float density { get; set; }
			public soy.atoms.Vector wind { owned get; set; }
		}
	}
	namespace joints {
		[CCode (cheader_filename = "soy.h")]
		public class Ball : soy.joints.Joint {
			public Ball (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Position anchor, soy.materials.Material? material);
			public override void create ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.atoms.Position anchor { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Fixed : soy.joints.Joint {
			public Fixed (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.materials.Material? material);
			public override void create ();
			public override void render ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Hinge : soy.joints.Joint {
			public Hinge (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Position anchor, soy.atoms.Axis axis, soy.materials.Material? material);
			public void addTorque (ode.Real torque);
			public override void create ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.atoms.Position anchor { owned get; set; }
			public soy.atoms.Axis axis { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Hinge2 : soy.joints.Joint {
			public Hinge2 (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Position anchor, soy.atoms.Axis axis1, soy.atoms.Axis axis2, soy.materials.Material? material);
			public void addTorques (ode.Real torque1, ode.Real torque2);
			public override void create ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.atoms.Position anchor { owned get; set; }
			public float angle { get; }
			public soy.atoms.Axis axis1 { owned get; set; }
			public soy.atoms.Axis axis2 { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Joint : GLib.Object {
			public weak soy.bodies.Body bodyA;
			public weak soy.bodies.Body? bodyB;
			public ode.joints.Joint joint;
			public GLib.Mutex mutex;
			public weak soy.scenes.Scene scene;
			public Joint (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2, soy.materials.Material? material);
			public virtual void create ();
			public virtual void mult_model_matrix ();
			public virtual void render ();
			public virtual void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.materials.Material material { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Piston : soy.joints.Joint {
			public Piston (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Position anchor, soy.atoms.Axis axis1, soy.atoms.Axis axis2, soy.materials.Material? material);
			public void addTorque (ode.Real torque);
			public override void create ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.atoms.Position anchor { owned get; set; }
			public float angle { get; }
			public soy.atoms.Axis axis1 { owned get; set; }
			public soy.atoms.Axis axis2 { owned get; set; }
			public float length { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Plane2D : soy.joints.Joint {
			public Plane2D (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.materials.Material? material);
			public override void create ();
			public void setAngleParam (int param, ode.Real val);
			public void setXParam (int param, ode.Real val);
			public void setYParam (int param, ode.Real val);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Slider : soy.joints.Joint {
			public Slider (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Axis axis, soy.materials.Material? material);
			public void addForce (ode.Real force);
			public override void create ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.atoms.Axis axis { owned get; set; }
			public float length { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Universal : soy.joints.Joint {
			public Universal (soy.scenes.Scene scene, soy.bodies.Body bodyA, soy.bodies.Body? bodyB, soy.atoms.Position anchor, soy.atoms.Axis axis1, soy.atoms.Axis axis2, soy.materials.Material? material);
			public void addTorques (ode.Real torque1, ode.Real torque2);
			public override void create ();
			public override void setup (soy.atoms.Position? anchor, soy.atoms.Axis? axis1, soy.atoms.Axis? axis2);
			public soy.atoms.Position anchor { owned get; set; }
			public float[] angle { owned get; }
			public soy.atoms.Axis axis1 { owned get; set; }
			public soy.atoms.Axis axis2 { owned get; set; }
		}
	}
	namespace materials {
		[CCode (cheader_filename = "soy.h")]
		public class Colored : soy.materials.Material {
			public Colored (string? name = null);
			public void enable_colors ();
			public void enable_shades ();
			public override bool render (int pass, GL.GLvoid* tslvs);
			public soy.atoms.Color ambient { owned get; set; }
			public soy.atoms.Color diffuse { owned get; set; }
			public soy.atoms.Color emission { owned get; set; }
			public int shades { get; set; }
			public float shininess { get; set; }
			public soy.atoms.Color specular { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Material : GLib.Object {
			public bool needsTSLVs;
			public bool translucent;
			public Material ();
			public virtual bool render (int pass, GL.GLvoid* tslvs);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Textured : soy.materials.Colored {
			public Textured (string? name = null, soy.textures.Texture? bumpmap, soy.textures.Texture? colormap, soy.textures.Texture? glowmap);
			public void disable_bumpmap (int id);
			public void disable_colormap (int id);
			public void disable_glowmap (int id);
			public void enable_bumpmap (int id);
			public void enable_colormap (int id);
			public void enable_glowmap (int id);
			public override bool render (int pass, GL.GLvoid* tslvs);
			public soy.textures.Texture? bumpmap { get; set; }
			public soy.textures.Texture? colormap { get; set; }
			public soy.textures.Texture? glowmap { get; set; }
		}
	}
	namespace net {
		[CCode (cheader_filename = "soy.h")]
		public class Client : GLib.Object {
			public soy.net.XMPPAgent agent;
			public bool connected;
			public Lm.Connection connection;
			public soy.atoms.Color glow;
			public soy.atoms.Color glow2;
			public float glow_amt;
			public string[] ids;
			public string password;
			public soy.scenes.Scene scene;
			public string server_jid;
			public string sid;
			public uint stream_id;
			public string username;
			public soy.widgets.Window window;
			public const int session_init_iq;
			public Client (string usr, string pwd, string sjid, string server, int port);
			public void auth_handler (Lm.Connection connection, bool success);
			public void can_done (uint stream_id);
			public void connection_handler (Lm.Connection connection, bool success);
			public void create_window ();
			public void cube (int pos);
			public Lm.HandlerResult iq_handler (Lm.MessageHandler handler, Lm.Connection connection, Lm.Message m);
			public uchar lerp (uchar @in, uchar in2, float amt);
			public void login ();
			public Lm.HandlerResult message_handler (Lm.MessageHandler handler, Lm.Connection connection, Lm.Message m);
			public void new_ice_xmpp_stanza (uint stream_id);
			public void process_glow ();
			public void recv (Nice.Agent agent, uint stream_id, uint component_id, uint len, string buf);
			public void send_message (string to, string body);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Server : GLib.Object {
			public soy.net.XMPPAgent agent;
			public string client_jid;
			public Gee.HashMap<uint,ClientData?> clients;
			public Lm.Connection connection;
			public string password;
			public GLib.SList<weak Nice.Candidate?> rcands;
			public string sid;
			public uint stream_id;
			public string username;
			public Server (string usr, string pwd, string server, int port);
			public void auth_handler (Lm.Connection connection, bool success);
			public void can_done (uint stream_id);
			public void connection_handler (Lm.Connection connection, bool success);
			public Lm.HandlerResult iq_handler (Lm.MessageHandler handler, Lm.Connection connection, Lm.Message m);
			public void recv (Nice.Agent agent, uint stream_id, uint component_id, uint len, string buf);
		}
		[CCode (cheader_filename = "soy.h")]
		public class XMPPAgent : GLib.Object {
			public Nice.Agent agent;
			public static Gee.HashMap<string,int> candidate_type_dict;
			public static Gee.HashMap<int,string> candidate_type_strs;
			public GLib.SList<weak Nice.Candidate?> lcands;
			public GLib.SList<weak Nice.Candidate?> rcands;
			public XMPPAgent ();
			public void add_local_candidates (Lm.MessageNode transport, GLib.SList<weak Nice.Candidate?> lcands);
			public void component_state_changed (uint p0, uint p1, Nice.ComponentState p2);
			public GLib.SList<weak Nice.Candidate?> get_remote_candidates (Lm.MessageNode transport, uint stream_id);
			public void initial_binding_request_received (uint p0);
			public void new_candidate (uint p0, uint p1, string p2);
			public void new_remote_candidate (uint p0, uint p1, string p2);
			public void new_selected_pair (uint p0, uint p1, string p2, string p3);
			public void reliable_transport_writable (uint p0, uint p1);
		}
	}
	namespace scenes {
		[CCode (cheader_filename = "soy.h")]
		public class Room : soy.scenes.Scene {
			public ode.geoms.Geom[] planes;
			public Room (float size);
			public override void render (GL.GLfloat fov, GL.GLfloat aspect, GL.GLfloat znear, GL.GLfloat zfar);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Scene : GLib.Object {
			public Gee.HashSet<soy.controllers.VirtualController> Controllers;
			public Gee.HashMap<string,soy.bodies.Body> bodies;
			public Gee.HashMap<ode.Body,soy.fields.Field> fields;
			public Gee.ArrayList<soy.joints.Joint> joints;
			public Gee.HashSet<soy.bodies.Light> lights;
			public ode.spaces.Space space;
			public GLib.RWLock stepLock;
			public ode.World world;
			public Scene ();
			public bool[] check_collisions (soy.atoms.Position start, soy.atoms.Position[] ends);
			public bool[] check_collisions_with_radius (soy.atoms.Position start, soy.atoms.Position[] ends, float radius);
			public bool[] check_collisions_with_size (soy.atoms.Position start, soy.atoms.Position[] ends, soy.atoms.Size aabb);
			public bool check_path_collision (soy.atoms.Position start, soy.atoms.Position end);
			public virtual void do_in_step ();
			public new soy.bodies.Body? @get (string key);
			public static void perspective (GL.GLfloat fovy, GL.GLfloat aspect, GL.GLfloat zNear, GL.GLfloat zFar);
			public virtual void render (GL.GLfloat fov, GL.GLfloat aspect, GL.GLfloat znear, GL.GLfloat zfar);
			public new void @set (string key, soy.bodies.Body? value);
			public bool step ();
			public soy.atoms.Color ambient { owned get; set; }
			public soy.atoms.Color fog { owned get; set; }
			public soy.atoms.Vector gravity { owned get; set; }
			public float stepsize { get; set; }
			public uint64 time { get; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class TDSide : soy.scenes.Scene {
			public Gee.HashMap<soy.bodies.Body,soy.joints.Plane2D> plane2ds;
			public Gee.LinkedList<soy.bodies.Body> tdbodies;
			public TDSide ();
			public override void do_in_step ();
			public void set2d (soy.bodies.Body body);
			public void set_vel_x (soy.bodies.Body body, float vel);
			public void set_vel_y (soy.bodies.Body body, float vel);
			public void unset2d (soy.bodies.Body body);
			public soy.atoms.Vector tdgravity { get; set; }
		}
	}
	namespace textures {
		[CCode (cheader_filename = "soy.h")]
		public class Cubemap : soy.textures.Texture {
			public Cubemap ();
			public override void disable ();
			public override void enable ();
			public soy.textures.Texture? back { get; set; }
			public soy.textures.Texture? down { get; set; }
			public soy.textures.Texture? front { get; set; }
			public soy.textures.Texture? left { get; set; }
			public soy.textures.Texture? right { get; set; }
			public soy.textures.Texture? up { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Texture : GLib.Object {
			public uchar* texels;
			public Texture ();
			public virtual void disable ();
			public virtual void enable ();
			public Texture.from_png (string filename);
			public Texture.from_svg (string filename);
			public new soy.atoms.Color? @get (int index);
			public void load (void* _vdata, int _size);
			public void resize (int c, int x, int y);
			public new void @set (int index, GLib.Object value);
			public static int squareup (int _v);
			public void update (GL.GLenum target);
			public GL.GLfloat[] animate { get; }
			public float aspect { get; }
			public int channels { get; set; }
			public soy.atoms.Size size { owned get; set; }
			public bool smooth { get; set; }
		}
	}
	namespace widgets {
		[CCode (cheader_filename = "soy.h")]
		public class Branch : soy.widgets.Container {
			public bool collapsed;
			public string name;
			public Branch (soy.widgets.Container? parent, string? name);
			public float convertY (float y);
			public void display ();
			public void remove_branch (soy.widgets.Branch oldBranch);
			public override void render (int x, int y, int width, int height);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Canvas : soy.widgets.Widget {
			public int alignHeight;
			public int alignWidth;
			public float aspect;
			public GL.GLuint ibuffer;
			public int marginBottom;
			public int marginLeft;
			public int marginRight;
			public int marginTop;
			public GL.GLuint vbuffer;
			public Canvas (soy.widgets.Container? parent, soy.textures.Texture? texture);
			public override void render (int x, int y, int width, int height);
			public soy.textures.Texture texture { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Container : soy.widgets.Widget {
			public Gee.LinkedList<soy.widgets.Widget> children;
			public Container (soy.widgets.Container? parent);
			public override void render (int x, int y, int width, int height);
			public override void resize (int x, int y, int width, int height);
			public virtual void resize_children (int x, int y, int width, int height);
		}
		[CCode (cheader_filename = "soy.h")]
		public class HBox : soy.widgets.Container {
			public HBox (soy.widgets.Container? parent);
			public override void render (int x, int y, int width, int height);
			public override void resize_children (int x, int y, int width, int height);
		}
		[CCode (cheader_filename = "soy.h")]
		public class HScroll : soy.widgets.Scroller {
			public HScroll (soy.widgets.Container? parent);
			public override void motion_handler (soy.events.Motion e);
			public override void render (int x, int y, int width, int height);
			public override void resize_children (int x, int y, int width, int height);
			public override void scroll_handler (soy.events.Scroll e);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Projector : soy.widgets.Widget {
			public Projector (soy.widgets.Container? parent, soy.bodies.Camera? camera = null);
			public override void render (int x, int y, int width, int height);
			public soy.bodies.Camera camera { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Scroller : soy.widgets.Container {
			public bool drag;
			public soy.widgets.Container parent;
			public soy.atoms.Position scrollPosition;
			public soy.atoms.Size scrollbarSize;
			public int scrollbarThickness;
			public float xpos_startdrag;
			public float xstartdrag;
			public float ypos_startdrag;
			public float ystartdrag;
			public Scroller (soy.widgets.Container? parent);
			public void button_press_handler (soy.events.Button e);
			public void button_release_handler (soy.events.Button e);
			public float convertY (float y);
			public bool hit_mouse (float x, float y);
			public virtual void motion_handler (soy.events.Motion e);
			public virtual void scroll_handler (soy.events.Scroll e);
			public soy.controllers.Pointer controller { get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class VBox : soy.widgets.Container {
			public VBox (soy.widgets.Container? parent);
			public override void render (int x, int y, int width, int height);
			public override void resize_children (int x, int y, int width, int height);
		}
		[CCode (cheader_filename = "soy.h")]
		public class VScroll : soy.widgets.Scroller {
			public VScroll (soy.widgets.Container? parent);
			public override void motion_handler (soy.events.Motion e);
			public override void render (int x, int y, int width, int height);
			public override void resize_children (int x, int y, int width, int height);
			public override void scroll_handler (soy.events.Scroll e);
		}
		[CCode (cheader_filename = "soy.h")]
		public class Widget : GLib.Object {
			public int height;
			public bool resized;
			public int width;
			public Widget (soy.widgets.Container? parent);
			public virtual void render (int x, int y, int width, int height);
			public virtual void resize (int x, int y, int width, int height);
			public soy.atoms.Size size { owned get; set; }
		}
		[CCode (cheader_filename = "soy.h")]
		public class Window : soy.widgets.Container {
			public Window (soy.widgets.Container? parent);
			public void draw ();
			public override void resize_children (int x, int y, int width, int height);
			public soy.atoms.Color background { owned get; set; }
			public int fps { get; }
			public soy.atoms.Position position { owned get; set; }
			public bool resizable { get; set; }
			public string title { get; set; }
		}
	}
	[CCode (cheader_filename = "soy.h")]
	public class IteratorWrapper<G> : GLib.Object, Gee.Iterable<G> {
		public IteratorWrapper (Gee.Iterator<G> iter);
	}
	[CCode (cheader_filename = "soy.h")]
	public class Mass : GLib.Object {
		public soy.bodies.Body body;
		public ode.Mass mass_;
		public Mass (soy.bodies.Body body);
		public void adjust (float newmass);
		public void box (float density = 1, float lx = 1, float ly = 1, float lz = 1);
		public void capsule (float density = 1, int direction = 1, float radius = 1, float length = 1);
		public void cylinder (float density = 1, int direction = 1, float radius = 1, float length = 1);
		public void sphere (float density = 1, float radius = 1);
		public float mass { get; set; }
	}
	[CCode (cheader_filename = "soy.h")]
	public class SGK2PNGConverter {
		public SGK2PNGConverter ();
		public uchar[] get_png ();
		public void sgk2png (uchar[] sgk_data);
		public Cairo.Status writefunc (uchar[] input);
		public Gee.ArrayList<uchar> png_data { get; set; }
	}
	[CCode (cheader_filename = "soy.h")]
	public enum Comparison {
		EQ,
		NE,
		GT,
		LT,
		GE,
		LE
	}
	[CCode (cheader_filename = "soy.h")]
	public enum EventType {
		KeyPress,
		KeyDown,
		KeyRelease,
		Motion,
		ButtonPress,
		ButtonRelease,
		Scroll,
		WiimoteButtonPress
	}
	[CCode (cheader_filename = "soy.h")]
	public enum ScrollDirection {
		Up,
		Down,
		Left,
		Right
	}
	[CCode (cheader_filename = "soy.h", has_target = false)]
	public delegate GLib.Object? loadable_func (string packet);
	[CCode (cheader_filename = "soy.h")]
	public static soy.materials.Material default_material;
	[CCode (cheader_filename = "soy.h")]
	public static Gee.HashMap<string,soy.loadable_func> loadable;
	[CCode (cheader_filename = "soy.h")]
	public static void init ();
	[CCode (cheader_filename = "soy.h")]
	public static string keyval_name (uint keyval);
}
[CCode (cheader_filename = "soy.h")]
public class ClientData {
	public weak GLib.SList<weak Nice.Candidate?> cands;
	public string jid;
	public string sid;
	public ClientData ();
}
[CCode (cheader_filename = "soy.h")]
public static ulong GeomScene;
[CCode (cheader_filename = "soy.h")]
public static ulong GeomBody;
[CCode (cheader_filename = "soy.h")]
public static ulong GeomField;
[CCode (cheader_filename = "soy.h")]
public static ulong GeomLight;
[CCode (cheader_filename = "soy.h")]
public static ulong GeomGhost;
[CCode (cheader_filename = "soy.h")]
public static ulong GeomTestRay;
[CCode (cheader_filename = "soy.h")]
public static ulong GeomIgnored;
