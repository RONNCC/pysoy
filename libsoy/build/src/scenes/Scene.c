/* Scene.c generated by valac 0.18.1, the Vala compiler
 * generated from Scene.gs, do not modify */

/*
 *  libsoy - soy.scenes.Scene
 *  Copyright (C) 2006,2007,2008,2009,2010,2011,2012 Copyleft Games Group
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program; if not, see http://www.gnu.org/licenses
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <GLES/gl.h>
#include <GLES/glext.h>
#include <ode.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define SOY_SCENES_TYPE_SCENE (soy_scenes_scene_get_type ())
#define SOY_SCENES_SCENE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_SCENES_TYPE_SCENE, soyscenesScene))
#define SOY_SCENES_SCENE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_SCENES_TYPE_SCENE, soyscenesSceneClass))
#define SOY_SCENES_IS_SCENE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_SCENES_TYPE_SCENE))
#define SOY_SCENES_IS_SCENE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_SCENES_TYPE_SCENE))
#define SOY_SCENES_SCENE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_SCENES_TYPE_SCENE, soyscenesSceneClass))

typedef struct _soyscenesScene soyscenesScene;
typedef struct _soyscenesSceneClass soyscenesSceneClass;
typedef struct _soyscenesScenePrivate soyscenesScenePrivate;

#define SOY_BODIES_TYPE_BODY (soy_bodies_body_get_type ())
#define SOY_BODIES_BODY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_BODY, soybodiesBody))
#define SOY_BODIES_BODY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_BODY, soybodiesBodyClass))
#define SOY_BODIES_IS_BODY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_BODY))
#define SOY_BODIES_IS_BODY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_BODY))
#define SOY_BODIES_BODY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_BODY, soybodiesBodyClass))

typedef struct _soybodiesBody soybodiesBody;
typedef struct _soybodiesBodyClass soybodiesBodyClass;

#define SOY_BODIES_TYPE_LIGHT (soy_bodies_light_get_type ())
#define SOY_BODIES_LIGHT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_LIGHT, soybodiesLight))
#define SOY_BODIES_LIGHT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_LIGHT, soybodiesLightClass))
#define SOY_BODIES_IS_LIGHT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_LIGHT))
#define SOY_BODIES_IS_LIGHT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_LIGHT))
#define SOY_BODIES_LIGHT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_LIGHT, soybodiesLightClass))

typedef struct _soybodiesLight soybodiesLight;
typedef struct _soybodiesLightClass soybodiesLightClass;

#define SOY_JOINTS_TYPE_JOINT (soy_joints_joint_get_type ())
#define SOY_JOINTS_JOINT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_JOINTS_TYPE_JOINT, soyjointsJoint))
#define SOY_JOINTS_JOINT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_JOINTS_TYPE_JOINT, soyjointsJointClass))
#define SOY_JOINTS_IS_JOINT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_JOINTS_TYPE_JOINT))
#define SOY_JOINTS_IS_JOINT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_JOINTS_TYPE_JOINT))
#define SOY_JOINTS_JOINT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_JOINTS_TYPE_JOINT, soyjointsJointClass))

typedef struct _soyjointsJoint soyjointsJoint;
typedef struct _soyjointsJointClass soyjointsJointClass;

#define SOY_CONTROLLERS_TYPE_CONTROLLER (soy_controllers_controller_get_type ())
#define SOY_CONTROLLERS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_CONTROLLERS_TYPE_CONTROLLER, soycontrollersController))
#define SOY_CONTROLLERS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_CONTROLLERS_TYPE_CONTROLLER, soycontrollersControllerClass))
#define SOY_CONTROLLERS_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_CONTROLLERS_TYPE_CONTROLLER))
#define SOY_CONTROLLERS_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_CONTROLLERS_TYPE_CONTROLLER))
#define SOY_CONTROLLERS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_CONTROLLERS_TYPE_CONTROLLER, soycontrollersControllerClass))

typedef struct _soycontrollersController soycontrollersController;
typedef struct _soycontrollersControllerClass soycontrollersControllerClass;

#define SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER (soy_controllers_virtual_controller_get_type ())
#define SOY_CONTROLLERS_VIRTUAL_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualController))
#define SOY_CONTROLLERS_VIRTUAL_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualControllerClass))
#define SOY_CONTROLLERS_IS_VIRTUAL_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER))
#define SOY_CONTROLLERS_IS_VIRTUAL_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER))
#define SOY_CONTROLLERS_VIRTUAL_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualControllerClass))

typedef struct _soycontrollersVirtualController soycontrollersVirtualController;
typedef struct _soycontrollersVirtualControllerClass soycontrollersVirtualControllerClass;

#define SOY_FIELDS_TYPE_FIELD (soy_fields_field_get_type ())
#define SOY_FIELDS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_FIELDS_TYPE_FIELD, soyfieldsField))
#define SOY_FIELDS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_FIELDS_TYPE_FIELD, soyfieldsFieldClass))
#define SOY_FIELDS_IS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_FIELDS_TYPE_FIELD))
#define SOY_FIELDS_IS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_FIELDS_TYPE_FIELD))
#define SOY_FIELDS_FIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_FIELDS_TYPE_FIELD, soyfieldsFieldClass))

typedef struct _soyfieldsField soyfieldsField;
typedef struct _soyfieldsFieldClass soyfieldsFieldClass;

#define SOY_ATOMS_TYPE_COLOR (soy_atoms_color_get_type ())
#define SOY_ATOMS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColor))
#define SOY_ATOMS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))
#define SOY_ATOMS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))

typedef struct _soyatomsColor soyatomsColor;
typedef struct _soyatomsColorClass soyatomsColorClass;

#define SOY_ATOMS_TYPE_VECTOR (soy_atoms_vector_get_type ())
#define SOY_ATOMS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_VECTOR, soyatomsVector))
#define SOY_ATOMS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_VECTOR, soyatomsVectorClass))
#define SOY_ATOMS_IS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_VECTOR))
#define SOY_ATOMS_IS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_VECTOR))
#define SOY_ATOMS_VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_VECTOR, soyatomsVectorClass))

typedef struct _soyatomsVector soyatomsVector;
typedef struct _soyatomsVectorClass soyatomsVectorClass;
#define _dWorldDestroy0(var) ((var == NULL) ? NULL : (var = (dWorldDestroy (var), NULL)))
#define _dSpaceDestroy0(var) ((var == NULL) ? NULL : (var = (dSpaceDestroy (var), NULL)))
#define _dJointGroupDestroy0(var) ((var == NULL) ? NULL : (var = (dJointGroupDestroy (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define SOY_SCENES_TYPE__PHYSICSTHREAD (soy_scenes__physicsthread_get_type ())
#define SOY_SCENES__PHYSICSTHREAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_SCENES_TYPE__PHYSICSTHREAD, soyscenes_PhysicsThread))
#define SOY_SCENES__PHYSICSTHREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_SCENES_TYPE__PHYSICSTHREAD, soyscenes_PhysicsThreadClass))
#define SOY_SCENES_IS__PHYSICSTHREAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_SCENES_TYPE__PHYSICSTHREAD))
#define SOY_SCENES_IS__PHYSICSTHREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_SCENES_TYPE__PHYSICSTHREAD))
#define SOY_SCENES__PHYSICSTHREAD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_SCENES_TYPE__PHYSICSTHREAD, soyscenes_PhysicsThreadClass))

typedef struct _soyscenes_PhysicsThread soyscenes_PhysicsThread;
typedef struct _soyscenes_PhysicsThreadClass soyscenes_PhysicsThreadClass;
typedef struct _soyscenes_PhysicsThreadPrivate soyscenes_PhysicsThreadPrivate;
#define _g_source_unref0(var) ((var == NULL) ? NULL : (var = (g_source_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SOY_ATOMS_TYPE_POSITION (soy_atoms_position_get_type ())
#define SOY_ATOMS_POSITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_POSITION, soyatomsPosition))
#define SOY_ATOMS_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_POSITION, soyatomsPositionClass))
#define SOY_ATOMS_IS_POSITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_POSITION))
#define SOY_ATOMS_IS_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_POSITION))
#define SOY_ATOMS_POSITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_POSITION, soyatomsPositionClass))

typedef struct _soyatomsPosition soyatomsPosition;
typedef struct _soyatomsPositionClass soyatomsPositionClass;
#define _dmatrix3_free0(var) ((var == NULL) ? NULL : (var = (dmatrix3_free (var), NULL)))

#define SOY_ATOMS_TYPE_SIZE (soy_atoms_size_get_type ())
#define SOY_ATOMS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSize))
#define SOY_ATOMS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))
#define SOY_ATOMS_IS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_IS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_SIZE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))

typedef struct _soyatomsSize soyatomsSize;
typedef struct _soyatomsSizeClass soyatomsSizeClass;
#define _dvector3_free0(var) ((var == NULL) ? NULL : (var = (dvector3_free (var), NULL)))

struct _soyscenesScene {
	GObject parent_instance;
	soyscenesScenePrivate * priv;
	struct dxWorld* world;
	struct dxSpace* space;
	GRWLock stepLock;
	GeeHashSet* lights;
	GeeHashMap* bodies;
	GeeArrayList* joints;
	GeeHashSet* Controllers;
	GeeHashMap* fields;
};

struct _soyscenesSceneClass {
	GObjectClass parent_class;
	void (*do_in_step) (soyscenesScene* self);
	void (*render) (soyscenesScene* self, GLfloat fov, GLfloat aspect, GLfloat znear, GLfloat zfar);
};

struct _soyscenesScenePrivate {
	struct dxJointGroup* _contactGroup;
	guint64 _lastStep;
	GTimeVal _tv;
	GeeLinkedList* _callFields;
	GeeLinkedList* _giveFields;
	guint64 _time;
	GLfloat* _ambient;
	gint _ambient_length1;
	gint __ambient_size_;
	soyatomsColor* _ambient_obj;
	GLfloat* _fog;
	gint _fog_length1;
	gint __fog_size_;
	soyatomsColor* _fog_obj;
	soyatomsVector* _gravity_obj;
	gfloat _stepsize;
};

struct _soyscenes_PhysicsThread {
	GObject parent_instance;
	soyscenes_PhysicsThreadPrivate * priv;
	GMainContext* context;
};

struct _soyscenes_PhysicsThreadClass {
	GObjectClass parent_class;
};


extern gulong GeomScene;
gulong GeomScene = (gulong) 1;
extern gulong GeomBody;
gulong GeomBody = (gulong) 2;
extern gulong GeomField;
gulong GeomField = (gulong) 4;
extern gulong GeomLight;
gulong GeomLight = (gulong) 8;
extern gulong GeomGhost;
gulong GeomGhost = (gulong) 16;
extern gulong GeomTestRay;
gulong GeomTestRay = (gulong) 32;
extern gulong GeomIgnored;
gulong GeomIgnored = (gulong) 64;
static gpointer soy_scenes_scene_parent_class = NULL;
extern soyscenes_PhysicsThread* soy_scenes__thread;

GType soy_scenes_scene_get_type (void) G_GNUC_CONST;
GType soy_bodies_body_get_type (void) G_GNUC_CONST;
GType soy_bodies_light_get_type (void) G_GNUC_CONST;
GType soy_joints_joint_get_type (void) G_GNUC_CONST;
GType soy_controllers_controller_get_type (void) G_GNUC_CONST;
GType soy_controllers_virtual_controller_get_type (void) G_GNUC_CONST;
GType soy_fields_field_get_type (void) G_GNUC_CONST;
GType soy_atoms_color_get_type (void) G_GNUC_CONST;
GType soy_atoms_vector_get_type (void) G_GNUC_CONST;
#define SOY_SCENES_SCENE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOY_SCENES_TYPE_SCENE, soyscenesScenePrivate))
enum  {
	SOY_SCENES_SCENE_DUMMY_PROPERTY,
	SOY_SCENES_SCENE_TIME,
	SOY_SCENES_SCENE_AMBIENT,
	SOY_SCENES_SCENE_FOG,
	SOY_SCENES_SCENE_GRAVITY,
	SOY_SCENES_SCENE_STEPSIZE
};
soyscenesScene* soy_scenes_scene_new (void);
soyscenesScene* soy_scenes_scene_construct (GType object_type);
gboolean soy_scenes_scene_step (soyscenesScene* self);
GType soy_scenes__physicsthread_get_type (void) G_GNUC_CONST;
soybodiesBody* soy_scenes_scene_get (soyscenesScene* self, const gchar* key);
void soy_scenes_scene_set (soyscenesScene* self, const gchar* key, soybodiesBody* value);
void soy_bodies_body_add (soybodiesBody* self, const gchar* k, soyscenesScene* v);
static void _soy_scenes_scene_collided (soyscenesScene* self, struct dxGeom* geomA, struct dxGeom* geomB);
void soy_fields_field_give (soyfieldsField* self, gint data);
gboolean soy_fields_field_apply (soyfieldsField* self);
void soy_fields_field_commit (soyfieldsField* self);
guint64 soy_scenes_scene_get_time (soyscenesScene* self);
void soy_scenes_scene_do_in_step (soyscenesScene* self);
void soy_controllers_virtual_controller_run_controller (soycontrollersVirtualController* self);
gboolean soy_controllers_virtual_controller_get_finished (soycontrollersVirtualController* self);
static void __soy_scenes_scene_collided_dnear_callback (gpointer self, struct dxGeom* o1, struct dxGeom* o2);
static void soy_scenes_scene_real_do_in_step (soyscenesScene* self);
void soy_scenes_scene_render (soyscenesScene* self, GLfloat fov, GLfloat aspect, GLfloat znear, GLfloat zfar);
static void soy_scenes_scene_real_render (soyscenesScene* self, GLfloat fov, GLfloat aspect, GLfloat znear, GLfloat zfar);
void soy_scenes_scene_perspective (GLfloat fovy, GLfloat aspect, GLfloat zNear, GLfloat zFar);
void soy_bodies_light_on (soybodiesLight* self, GLenum id);
void soy_bodies_body_render (soybodiesBody* self);
void soy_joints_joint_render (soyjointsJoint* self);
void soy_bodies_light_off (soybodiesLight* self, GLenum id);
static void _soy_scenes_scene_check_collisions_NearCallback (soyscenesScene* self, struct dxGeom* o1, struct dxGeom* o2);
static void __soy_scenes_scene_check_collisions_NearCallback_dnear_callback (gpointer self, struct dxGeom* o1, struct dxGeom* o2);
GType soy_atoms_position_get_type (void) G_GNUC_CONST;
gboolean soy_scenes_scene_check_path_collision (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition* end);
gboolean* soy_scenes_scene_check_collisions (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition** ends, int ends_length1, int* result_length1);
gfloat soy_atoms_position_get_x (soyatomsPosition* self);
gfloat soy_atoms_position_get_y (soyatomsPosition* self);
gfloat soy_atoms_position_get_z (soyatomsPosition* self);
gboolean* soy_scenes_scene_check_collisions_with_radius (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition** ends, int ends_length1, gfloat radius, int* result_length1);
GType soy_atoms_size_get_type (void) G_GNUC_CONST;
gboolean* soy_scenes_scene_check_collisions_with_size (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition** ends, int ends_length1, soyatomsSize* aabb, int* result_length1);
gfloat soy_atoms_size_get_width (soyatomsSize* self);
gfloat soy_atoms_size_get_height (soyatomsSize* self);
gfloat soy_atoms_size_get_depth (soyatomsSize* self);
static void _soy_scenes_scene_ambient_set (soyscenesScene* self, soyatomsColor* color);
gfloat* soy_atoms_color_get4f (soyatomsColor* self, int* result_length1);
static void _soy_scenes_scene_ambient_weak (soyscenesScene* self, GObject* ambient);
static void _soy_scenes_scene_fog_set (soyscenesScene* self, soyatomsColor* color);
static void _soy_scenes_scene_fog_weak (soyscenesScene* self, GObject* ambient);
static void _soy_scenes_scene_gravity_set (soyscenesScene* self, soyatomsVector* gravity);
gfloat soy_atoms_vector_get_x (soyatomsVector* self);
gfloat soy_atoms_vector_get_y (soyatomsVector* self);
gfloat soy_atoms_vector_get_z (soyatomsVector* self);
static void _soy_scenes_scene_gravity_weak (soyscenesScene* self, GObject* gravity);
soyatomsColor* soy_scenes_scene_get_ambient (soyscenesScene* self);
soyatomsColor* soy_atoms_color_new_new4f (gfloat* rgba, int rgba_length1);
soyatomsColor* soy_atoms_color_construct_new4f (GType object_type, gfloat* rgba, int rgba_length1);
static void __soy_scenes_scene_ambient_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self);
static void __soy_scenes_scene_ambient_weak_gweak_notify (gpointer self, GObject* object);
void soy_scenes_scene_set_ambient (soyscenesScene* self, soyatomsColor* value);
soyatomsColor* soy_scenes_scene_get_fog (soyscenesScene* self);
static void __soy_scenes_scene_fog_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self);
static void __soy_scenes_scene_fog_weak_gweak_notify (gpointer self, GObject* object);
void soy_scenes_scene_set_fog (soyscenesScene* self, soyatomsColor* value);
soyatomsVector* soy_scenes_scene_get_gravity (soyscenesScene* self);
soyatomsVector* soy_atoms_vector_new (gfloat x, gfloat y, gfloat z);
soyatomsVector* soy_atoms_vector_construct (GType object_type, gfloat x, gfloat y, gfloat z);
static void __soy_scenes_scene_gravity_set_soy_atoms_vector_on_set (soyatomsVector* _sender, soyatomsVector* vector, gpointer self);
static void __soy_scenes_scene_gravity_weak_gweak_notify (gpointer self, GObject* object);
void soy_scenes_scene_set_gravity (soyscenesScene* self, soyatomsVector* value);
gfloat soy_scenes_scene_get_stepsize (soyscenesScene* self);
void soy_scenes_scene_set_stepsize (soyscenesScene* self, gfloat value);
soyscenes_PhysicsThread* soy_scenes__physicsthread_new (void);
soyscenes_PhysicsThread* soy_scenes__physicsthread_construct (GType object_type);
static void soy_scenes_scene_finalize (GObject* obj);
static void _vala_soy_scenes_scene_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_soy_scenes_scene_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_clear_GMutex (GMutex * mutex);
static void _vala_clear_GRecMutex (GRecMutex * mutex);
static void _vala_clear_GRWLock (GRWLock * mutex);
static void _vala_clear_GCond (GCond * mutex);


soyscenesScene* soy_scenes_scene_construct (GType object_type) {
	soyscenesScene * self = NULL;
	GeeHashSet* _tmp0_;
	GeeHashMap* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeHashSet* _tmp3_;
	GeeHashMap* _tmp4_;
	GeeLinkedList* _tmp5_;
	GeeLinkedList* _tmp6_;
	GLfloat* _tmp7_ = NULL;
	GLfloat* _tmp8_ = NULL;
	struct dxWorld* _tmp9_;
	struct dxSpace* _tmp10_;
	struct dxJointGroup* _tmp11_;
	GTimeVal _tmp12_;
	glong _tmp13_;
	GTimeVal _tmp14_;
	glong _tmp15_;
	GTimeVal _tmp16_;
	glong _tmp17_;
	GTimeVal _tmp18_;
	glong _tmp19_;
	GSource* _tmp20_;
	GSource* source;
	soyscenes_PhysicsThread* _tmp21_;
	GMainContext* _tmp22_;
	self = (soyscenesScene*) g_object_new (object_type, NULL);
	_vala_clear_GRWLock (&self->stepLock);
	g_rw_lock_init (&self->stepLock);
	_tmp0_ = gee_hash_set_new (SOY_BODIES_TYPE_LIGHT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL);
	_g_object_unref0 (self->lights);
	self->lights = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SOY_BODIES_TYPE_BODY, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->bodies);
	self->bodies = _tmp1_;
	_tmp2_ = gee_array_list_new (SOY_JOINTS_TYPE_JOINT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->joints);
	self->joints = _tmp2_;
	_tmp3_ = gee_hash_set_new (SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL);
	_g_object_unref0 (self->Controllers);
	self->Controllers = _tmp3_;
	_tmp4_ = gee_hash_map_new (G_TYPE_POINTER, NULL, NULL, SOY_FIELDS_TYPE_FIELD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->fields);
	self->fields = _tmp4_;
	_tmp5_ = gee_linked_list_new (SOY_FIELDS_TYPE_FIELD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->_callFields);
	self->priv->_callFields = _tmp5_;
	_tmp6_ = gee_linked_list_new (SOY_FIELDS_TYPE_FIELD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->_giveFields);
	self->priv->_giveFields = _tmp6_;
	_tmp7_ = g_new0 (GLfloat, 4);
	_tmp7_[0] = (GLfloat) 0.5f;
	_tmp7_[1] = (GLfloat) 0.5f;
	_tmp7_[2] = (GLfloat) 0.5f;
	_tmp7_[3] = (GLfloat) 1.0f;
	self->priv->_ambient = (g_free (self->priv->_ambient), NULL);
	self->priv->_ambient = _tmp7_;
	self->priv->_ambient_length1 = 4;
	self->priv->__ambient_size_ = self->priv->_ambient_length1;
	_tmp8_ = g_new0 (GLfloat, 4);
	_tmp8_[0] = (GLfloat) 0.0f;
	_tmp8_[1] = (GLfloat) 0.0f;
	_tmp8_[2] = (GLfloat) 0.0f;
	_tmp8_[3] = (GLfloat) 0.0f;
	self->priv->_fog = (g_free (self->priv->_fog), NULL);
	self->priv->_fog = _tmp8_;
	self->priv->_fog_length1 = 4;
	self->priv->__fog_size_ = self->priv->_fog_length1;
	_tmp9_ = dWorldCreate ();
	_dWorldDestroy0 (self->world);
	self->world = _tmp9_;
	_tmp10_ = dSimpleSpaceCreate (NULL);
	_dSpaceDestroy0 (self->space);
	self->space = _tmp10_;
	_tmp11_ = dJointGroupCreate (0);
	_dJointGroupDestroy0 (self->priv->_contactGroup);
	self->priv->_contactGroup = _tmp11_;
	g_get_current_time (&self->priv->_tv);
	_tmp12_ = self->priv->_tv;
	_tmp13_ = _tmp12_.tv_sec;
	_tmp14_ = self->priv->_tv;
	_tmp15_ = _tmp14_.tv_usec;
	self->priv->_time = (((guint64) _tmp13_) * 1000) + (((guint64) _tmp15_) / 1000);
	_tmp16_ = self->priv->_tv;
	_tmp17_ = _tmp16_.tv_sec;
	_tmp18_ = self->priv->_tv;
	_tmp19_ = _tmp18_.tv_usec;
	self->priv->_lastStep = (((guint64) _tmp17_) * 1000) + (((guint64) _tmp19_) / 1000);
	_tmp20_ = g_timeout_source_new ((guint) 10);
	source = _tmp20_;
	g_source_set_callback (source, (GSourceFunc) soy_scenes_scene_step, g_object_ref (self), g_object_unref);
	_tmp21_ = soy_scenes__thread;
	_tmp22_ = _tmp21_->context;
	g_source_attach (source, _tmp22_);
	_g_source_unref0 (source);
	return self;
}


soyscenesScene* soy_scenes_scene_new (void) {
	return soy_scenes_scene_construct (SOY_SCENES_TYPE_SCENE);
}


soybodiesBody* soy_scenes_scene_get (soyscenesScene* self, const gchar* key) {
	soybodiesBody* result = NULL;
	GeeHashMap* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	GeeSet* _tmp3_;
	const gchar* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = self->bodies;
	_tmp1_ = gee_abstract_map_get_keys ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = key;
	_tmp5_ = gee_collection_contains ((GeeCollection*) _tmp3_, _tmp4_);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp3_);
	if (_tmp6_) {
		GeeHashMap* _tmp7_;
		const gchar* _tmp8_;
		gpointer _tmp9_ = NULL;
		_tmp7_ = self->bodies;
		_tmp8_ = key;
		_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
		result = (soybodiesBody*) _tmp9_;
		return result;
	}
	result = NULL;
	return result;
}


void soy_scenes_scene_set (soyscenesScene* self, const gchar* key, soybodiesBody* value) {
	GeeHashMap* _tmp0_;
	const gchar* _tmp1_;
	soybodiesBody* _tmp2_;
	soybodiesBody* _tmp3_;
	const gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_rw_lock_writer_lock (&self->stepLock);
	_tmp0_ = self->bodies;
	_tmp1_ = key;
	_tmp2_ = value;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp0_, _tmp1_, _tmp2_);
	_tmp3_ = value;
	_tmp4_ = key;
	soy_bodies_body_add (_tmp3_, _tmp4_, self);
	g_rw_lock_writer_unlock (&self->stepLock);
}


static void _soy_scenes_scene_collided (soyscenesScene* self, struct dxGeom* geomA, struct dxGeom* geomB) {
	gint numberOfContacts = 0;
	dContactGeom* _tmp0_;
	dContactGeom* contactGeoms;
	struct dxBody* bodyA;
	struct dxBody* bodyB;
	dContact contact = {0};
	struct dxGeom* _tmp1_;
	struct dxGeom* _tmp2_;
	dContactGeom* _tmp3_;
	gint _tmp4_ = 0;
	gint _tmp5_;
	struct dxGeom* _tmp6_;
	gulong _tmp7_ = 0UL;
	gulong _tmp8_;
	struct dxGeom* _tmp11_;
	gulong _tmp12_ = 0UL;
	gulong _tmp13_;
	struct dxGeom* _tmp16_;
	gulong _tmp17_ = 0UL;
	gulong _tmp18_;
	struct dxGeom* _tmp19_;
	gulong _tmp20_ = 0UL;
	gulong _tmp21_;
	struct dxBody* _tmp22_;
	struct dxBody* _tmp23_;
	GeeHashMap* _tmp24_;
	struct dxBody* _tmp25_;
	gboolean _tmp26_ = FALSE;
	GeeHashMap* _tmp32_;
	struct dxBody* _tmp33_;
	gboolean _tmp34_ = FALSE;
	gint _tmp40_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (geomA != NULL);
	g_return_if_fail (geomB != NULL);
	_tmp0_ = dcontact_geom_array_new (4);
	contactGeoms = _tmp0_;
	bodyA = NULL;
	bodyB = NULL;
	memset (&contact, 0, sizeof (dContact));
	_tmp1_ = geomA;
	_tmp2_ = geomB;
	_tmp3_ = contactGeoms;
	_tmp4_ = dCollide (_tmp1_, _tmp2_, 4, _tmp3_, (gint) sizeof (dContactGeom));
	numberOfContacts = _tmp4_;
	_tmp5_ = numberOfContacts;
	if (_tmp5_ == 0) {
		return;
	}
	_tmp6_ = geomA;
	_tmp7_ = dGeomGetCategoryBits (_tmp6_);
	_tmp8_ = GeomScene;
	if (_tmp7_ != _tmp8_) {
		struct dxGeom* _tmp9_;
		struct dxBody* _tmp10_ = NULL;
		_tmp9_ = geomA;
		_tmp10_ = dGeomGetBody (_tmp9_);
		bodyA = _tmp10_;
	}
	_tmp11_ = geomB;
	_tmp12_ = dGeomGetCategoryBits (_tmp11_);
	_tmp13_ = GeomScene;
	if (_tmp12_ != _tmp13_) {
		struct dxGeom* _tmp14_;
		struct dxBody* _tmp15_ = NULL;
		_tmp14_ = geomB;
		_tmp15_ = dGeomGetBody (_tmp14_);
		bodyB = _tmp15_;
	}
	_tmp16_ = geomA;
	_tmp17_ = dGeomGetCategoryBits (_tmp16_);
	_tmp18_ = GeomGhost;
	if (_tmp17_ == _tmp18_) {
		bodyB = NULL;
	}
	_tmp19_ = geomB;
	_tmp20_ = dGeomGetCategoryBits (_tmp19_);
	_tmp21_ = GeomGhost;
	if (_tmp20_ == _tmp21_) {
		bodyA = NULL;
	}
	_tmp22_ = bodyA;
	_tmp23_ = bodyB;
	if (_tmp22_ == _tmp23_) {
		return;
	}
	_tmp24_ = self->fields;
	_tmp25_ = bodyA;
	_tmp26_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp24_, _tmp25_);
	if (_tmp26_) {
		GeeLinkedList* _tmp27_;
		GeeHashMap* _tmp28_;
		struct dxBody* _tmp29_;
		gpointer _tmp30_ = NULL;
		soyfieldsField* _tmp31_;
		_tmp27_ = self->priv->_callFields;
		_tmp28_ = self->fields;
		_tmp29_ = bodyA;
		_tmp30_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp28_, _tmp29_);
		_tmp31_ = (soyfieldsField*) _tmp30_;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp27_, _tmp31_);
		_g_object_unref0 (_tmp31_);
	}
	_tmp32_ = self->fields;
	_tmp33_ = bodyB;
	_tmp34_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp32_, _tmp33_);
	if (_tmp34_) {
		GeeLinkedList* _tmp35_;
		GeeHashMap* _tmp36_;
		struct dxBody* _tmp37_;
		gpointer _tmp38_ = NULL;
		soyfieldsField* _tmp39_;
		_tmp35_ = self->priv->_callFields;
		_tmp36_ = self->fields;
		_tmp37_ = bodyB;
		_tmp38_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp36_, _tmp37_);
		_tmp39_ = (soyfieldsField*) _tmp38_;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp35_, _tmp39_);
		_g_object_unref0 (_tmp39_);
	}
	_tmp40_ = numberOfContacts;
	numberOfContacts = _tmp40_ - 1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp41_;
			_tmp41_ = TRUE;
			while (TRUE) {
				gboolean _tmp42_;
				gint _tmp44_;
				dContactGeom* _tmp45_;
				gint _tmp46_;
				dContactGeom _tmp47_ = {0};
				struct dxWorld* _tmp48_;
				struct dxJointGroup* _tmp49_;
				dContact _tmp50_;
				struct dxJoint* _tmp51_;
				struct dxJoint* joint;
				struct dxJoint* _tmp52_;
				struct dxBody* _tmp53_;
				struct dxBody* _tmp54_;
				_tmp42_ = _tmp41_;
				if (!_tmp42_) {
					gint _tmp43_;
					_tmp43_ = i;
					i = _tmp43_ + 1;
				}
				_tmp41_ = FALSE;
				_tmp44_ = numberOfContacts;
				if (!(i <= _tmp44_)) {
					break;
				}
				_tmp45_ = contactGeoms;
				_tmp46_ = i;
				dcontact_geom_array_get (_tmp45_, _tmp46_, &_tmp47_);
				contact.geom = _tmp47_;
				contact.surface.mode = (gint) dContactBounce;
				contact.surface.mu = (dReal) 0.0;
				contact.surface.bounce = (dReal) 0.8;
				contact.surface.bounce_vel = (dReal) 0.0;
				_tmp48_ = self->world;
				_tmp49_ = self->priv->_contactGroup;
				_tmp50_ = contact;
				_tmp51_ = dJointCreateContact (_tmp48_, _tmp49_, &_tmp50_);
				joint = _tmp51_;
				_tmp52_ = joint;
				_tmp53_ = bodyA;
				_tmp54_ = bodyB;
				dJointAttach (_tmp52_, _tmp53_, _tmp54_);
			}
		}
	}
	return;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __soy_scenes_scene_collided_dnear_callback (gpointer self, struct dxGeom* o1, struct dxGeom* o2) {
	_soy_scenes_scene_collided (self, o1, o2);
}


gboolean soy_scenes_scene_step (soyscenesScene* self) {
	gboolean result = FALSE;
	GeeLinkedList* _tmp0_;
	GeeLinkedList* _tmp1_;
	GeeLinkedList* _tmp44_;
	GeeLinkedList* finished_controllers;
	GTimeVal _tmp45_;
	glong _tmp46_;
	GTimeVal _tmp47_;
	glong _tmp48_;
	guint64 _tmp49_;
	guint64 _tmp50_;
	guint64 _tmp51_;
	glong _tmp52_ = 0L;
	glong steps;
	guint64 _tmp53_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_callFields;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
	_tmp1_ = self->priv->_giveFields;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp1_);
	{
		GeeHashMap* _tmp2_;
		GeeCollection* _tmp3_;
		GeeCollection* _tmp4_;
		GeeCollection* _tmp5_;
		GeeIterator* _tmp6_ = NULL;
		GeeIterator* _tmp7_;
		GeeIterator* _field_it;
		_tmp2_ = self->fields;
		_tmp3_ = gee_abstract_map_get_values ((GeeMap*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		_tmp6_ = gee_iterable_iterator ((GeeIterable*) _tmp5_);
		_tmp7_ = _tmp6_;
		_g_object_unref0 (_tmp5_);
		_field_it = _tmp7_;
		while (TRUE) {
			GeeIterator* _tmp8_;
			gboolean _tmp9_ = FALSE;
			GeeIterator* _tmp10_;
			gpointer _tmp11_ = NULL;
			soyfieldsField* field;
			GeeLinkedList* _tmp12_;
			soyfieldsField* _tmp13_;
			gboolean _tmp14_ = FALSE;
			_tmp8_ = _field_it;
			_tmp9_ = gee_iterator_next (_tmp8_);
			if (!_tmp9_) {
				break;
			}
			_tmp10_ = _field_it;
			_tmp11_ = gee_iterator_get (_tmp10_);
			field = (soyfieldsField*) _tmp11_;
			_tmp12_ = self->priv->_giveFields;
			_tmp13_ = field;
			_tmp14_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp12_, _tmp13_);
			if (!_tmp14_) {
				soyfieldsField* _tmp15_;
				GeeLinkedList* _tmp16_;
				soyfieldsField* _tmp17_;
				_tmp15_ = field;
				soy_fields_field_give (_tmp15_, 0);
				_tmp16_ = self->priv->_giveFields;
				_tmp17_ = field;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, _tmp17_);
			}
			_g_object_unref0 (field);
		}
		_g_object_unref0 (_field_it);
	}
	{
		GeeHashMap* _tmp18_;
		GeeCollection* _tmp19_;
		GeeCollection* _tmp20_;
		GeeCollection* _tmp21_;
		GeeIterator* _tmp22_ = NULL;
		GeeIterator* _tmp23_;
		GeeIterator* _field_it;
		_tmp18_ = self->fields;
		_tmp19_ = gee_abstract_map_get_values ((GeeMap*) _tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = _tmp20_;
		_tmp22_ = gee_iterable_iterator ((GeeIterable*) _tmp21_);
		_tmp23_ = _tmp22_;
		_g_object_unref0 (_tmp21_);
		_field_it = _tmp23_;
		while (TRUE) {
			GeeIterator* _tmp24_;
			gboolean _tmp25_ = FALSE;
			GeeIterator* _tmp26_;
			gpointer _tmp27_ = NULL;
			soyfieldsField* field;
			soyfieldsField* _tmp28_;
			gboolean _tmp29_ = FALSE;
			_tmp24_ = _field_it;
			_tmp25_ = gee_iterator_next (_tmp24_);
			if (!_tmp25_) {
				break;
			}
			_tmp26_ = _field_it;
			_tmp27_ = gee_iterator_get (_tmp26_);
			field = (soyfieldsField*) _tmp27_;
			_tmp28_ = field;
			_tmp29_ = soy_fields_field_apply (_tmp28_);
			if (!_tmp29_) {
				GeeLinkedList* _tmp30_;
				soyfieldsField* _tmp31_;
				_tmp30_ = self->priv->_callFields;
				_tmp31_ = field;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp30_, _tmp31_);
			}
			_g_object_unref0 (field);
		}
		_g_object_unref0 (_field_it);
	}
	{
		GeeLinkedList* _tmp32_;
		GeeLinkedList* _tmp33_;
		GeeLinkedList* _field_list;
		GeeLinkedList* _tmp34_;
		gint _tmp35_;
		gint _tmp36_;
		gint _field_size;
		gint _field_index;
		_tmp32_ = self->priv->_callFields;
		_tmp33_ = _g_object_ref0 (_tmp32_);
		_field_list = _tmp33_;
		_tmp34_ = _field_list;
		_tmp35_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp34_);
		_tmp36_ = _tmp35_;
		_field_size = _tmp36_;
		_field_index = -1;
		while (TRUE) {
			gint _tmp37_;
			gint _tmp38_;
			gint _tmp39_;
			GeeLinkedList* _tmp40_;
			gint _tmp41_;
			gpointer _tmp42_ = NULL;
			soyfieldsField* field;
			soyfieldsField* _tmp43_;
			_tmp37_ = _field_index;
			_field_index = _tmp37_ + 1;
			_tmp38_ = _field_index;
			_tmp39_ = _field_size;
			if (!(_tmp38_ < _tmp39_)) {
				break;
			}
			_tmp40_ = _field_list;
			_tmp41_ = _field_index;
			_tmp42_ = gee_abstract_list_get ((GeeAbstractList*) _tmp40_, _tmp41_);
			field = (soyfieldsField*) _tmp42_;
			_tmp43_ = field;
			soy_fields_field_commit (_tmp43_);
			_g_object_unref0 (field);
		}
		_g_object_unref0 (_field_list);
	}
	_tmp44_ = gee_linked_list_new (SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	finished_controllers = _tmp44_;
	g_get_current_time (&self->priv->_tv);
	_tmp45_ = self->priv->_tv;
	_tmp46_ = _tmp45_.tv_sec;
	_tmp47_ = self->priv->_tv;
	_tmp48_ = _tmp47_.tv_usec;
	self->priv->_time = (((guint64) _tmp46_) * 1000) + (((guint64) _tmp48_) / 1000);
	_tmp49_ = soy_scenes_scene_get_time (self);
	_tmp50_ = _tmp49_;
	_tmp51_ = self->priv->_lastStep;
	_tmp52_ = lround ((gdouble) ((_tmp50_ - _tmp51_) / 10));
	steps = _tmp52_;
	_tmp53_ = self->priv->_time;
	self->priv->_lastStep = _tmp53_;
	g_rw_lock_writer_lock (&self->stepLock);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp54_;
			_tmp54_ = TRUE;
			while (TRUE) {
				gboolean _tmp55_;
				glong _tmp57_;
				GTimeVal _tmp58_;
				glong _tmp59_;
				GTimeVal _tmp60_;
				glong _tmp61_;
				GeeLinkedList* _tmp74_;
				GeeHashSet* _tmp87_;
				GeeLinkedList* _tmp88_;
				GeeLinkedList* _tmp89_;
				struct dxSpace* _tmp90_;
				struct dxWorld* _tmp91_;
				struct dxJointGroup* _tmp92_;
				gint _tmp93_;
				_tmp55_ = _tmp54_;
				if (!_tmp55_) {
					gint _tmp56_;
					_tmp56_ = i;
					i = _tmp56_ + 1;
				}
				_tmp54_ = FALSE;
				_tmp57_ = steps;
				if (!(i <= _tmp57_)) {
					break;
				}
				g_get_current_time (&self->priv->_tv);
				_tmp58_ = self->priv->_tv;
				_tmp59_ = _tmp58_.tv_sec;
				_tmp60_ = self->priv->_tv;
				_tmp61_ = _tmp60_.tv_usec;
				self->priv->_time = (((guint64) _tmp59_) * 1000) + (((guint64) _tmp61_) / 1000);
				soy_scenes_scene_do_in_step (self);
				{
					GeeLinkedList* _tmp62_;
					GeeLinkedList* _tmp63_;
					GeeLinkedList* _field_list;
					GeeLinkedList* _tmp64_;
					gint _tmp65_;
					gint _tmp66_;
					gint _field_size;
					gint _field_index;
					_tmp62_ = self->priv->_giveFields;
					_tmp63_ = _g_object_ref0 (_tmp62_);
					_field_list = _tmp63_;
					_tmp64_ = _field_list;
					_tmp65_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp64_);
					_tmp66_ = _tmp65_;
					_field_size = _tmp66_;
					_field_index = -1;
					while (TRUE) {
						gint _tmp67_;
						gint _tmp68_;
						gint _tmp69_;
						GeeLinkedList* _tmp70_;
						gint _tmp71_;
						gpointer _tmp72_ = NULL;
						soyfieldsField* field;
						soyfieldsField* _tmp73_;
						_tmp67_ = _field_index;
						_field_index = _tmp67_ + 1;
						_tmp68_ = _field_index;
						_tmp69_ = _field_size;
						if (!(_tmp68_ < _tmp69_)) {
							break;
						}
						_tmp70_ = _field_list;
						_tmp71_ = _field_index;
						_tmp72_ = gee_abstract_list_get ((GeeAbstractList*) _tmp70_, _tmp71_);
						field = (soyfieldsField*) _tmp72_;
						_tmp73_ = field;
						soy_fields_field_give (_tmp73_, 1);
						_g_object_unref0 (field);
					}
					_g_object_unref0 (_field_list);
				}
				_tmp74_ = self->priv->_callFields;
				gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp74_);
				{
					GeeHashSet* _tmp75_;
					GeeIterator* _tmp76_ = NULL;
					GeeIterator* _cont_it;
					_tmp75_ = self->Controllers;
					_tmp76_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp75_);
					_cont_it = _tmp76_;
					while (TRUE) {
						GeeIterator* _tmp77_;
						gboolean _tmp78_ = FALSE;
						GeeIterator* _tmp79_;
						gpointer _tmp80_ = NULL;
						soycontrollersVirtualController* cont;
						soycontrollersVirtualController* _tmp81_;
						soycontrollersVirtualController* _tmp82_;
						gboolean _tmp83_;
						gboolean _tmp84_;
						_tmp77_ = _cont_it;
						_tmp78_ = gee_iterator_next (_tmp77_);
						if (!_tmp78_) {
							break;
						}
						_tmp79_ = _cont_it;
						_tmp80_ = gee_iterator_get (_tmp79_);
						cont = (soycontrollersVirtualController*) _tmp80_;
						_tmp81_ = cont;
						soy_controllers_virtual_controller_run_controller (_tmp81_);
						_tmp82_ = cont;
						_tmp83_ = soy_controllers_virtual_controller_get_finished (_tmp82_);
						_tmp84_ = _tmp83_;
						if (_tmp84_) {
							GeeLinkedList* _tmp85_;
							soycontrollersVirtualController* _tmp86_;
							_tmp85_ = finished_controllers;
							_tmp86_ = cont;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp85_, _tmp86_);
						}
						_g_object_unref0 (cont);
					}
					_g_object_unref0 (_cont_it);
				}
				_tmp87_ = self->Controllers;
				_tmp88_ = finished_controllers;
				gee_abstract_collection_remove_all ((GeeAbstractCollection*) _tmp87_, (GeeCollection*) _tmp88_);
				_tmp89_ = finished_controllers;
				gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp89_);
				_tmp90_ = self->space;
				dSpaceCollide (_tmp90_, self, __soy_scenes_scene_collided_dnear_callback);
				_tmp91_ = self->world;
				dWorldQuickStep (_tmp91_, (dReal) 0.01f);
				_tmp92_ = self->priv->_contactGroup;
				dJointGroupEmpty (_tmp92_);
				_tmp93_ = i;
				if (_tmp93_ != 0) {
					{
						GeeLinkedList* _tmp94_;
						GeeLinkedList* _tmp95_;
						GeeLinkedList* _field_list;
						GeeLinkedList* _tmp96_;
						gint _tmp97_;
						gint _tmp98_;
						gint _field_size;
						gint _field_index;
						_tmp94_ = self->priv->_callFields;
						_tmp95_ = _g_object_ref0 (_tmp94_);
						_field_list = _tmp95_;
						_tmp96_ = _field_list;
						_tmp97_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp96_);
						_tmp98_ = _tmp97_;
						_field_size = _tmp98_;
						_field_index = -1;
						while (TRUE) {
							gint _tmp99_;
							gint _tmp100_;
							gint _tmp101_;
							GeeLinkedList* _tmp102_;
							gint _tmp103_;
							gpointer _tmp104_ = NULL;
							soyfieldsField* field;
							soyfieldsField* _tmp105_;
							_tmp99_ = _field_index;
							_field_index = _tmp99_ + 1;
							_tmp100_ = _field_index;
							_tmp101_ = _field_size;
							if (!(_tmp100_ < _tmp101_)) {
								break;
							}
							_tmp102_ = _field_list;
							_tmp103_ = _field_index;
							_tmp104_ = gee_abstract_list_get ((GeeAbstractList*) _tmp102_, _tmp103_);
							field = (soyfieldsField*) _tmp104_;
							_tmp105_ = field;
							soy_fields_field_give (_tmp105_, 0);
							_g_object_unref0 (field);
						}
						_g_object_unref0 (_field_list);
					}
				}
			}
		}
	}
	g_rw_lock_writer_unlock (&self->stepLock);
	result = TRUE;
	_g_object_unref0 (finished_controllers);
	return result;
}


static void soy_scenes_scene_real_do_in_step (soyscenesScene* self) {
}


void soy_scenes_scene_do_in_step (soyscenesScene* self) {
	g_return_if_fail (self != NULL);
	SOY_SCENES_SCENE_GET_CLASS (self)->do_in_step (self);
}


static void soy_scenes_scene_real_render (soyscenesScene* self, GLfloat fov, GLfloat aspect, GLfloat znear, GLfloat zfar) {
	GLenum i = 0U;
	GLfloat _tmp0_;
	GLfloat _tmp1_;
	GLfloat _tmp2_;
	GLfloat _tmp3_;
	GLfloat* _tmp4_;
	gint _tmp4__length1;
	GLfloat* _tmp5_;
	gint _tmp5__length1;
	GLfloat _tmp6_;
	GLfloat* _tmp54_;
	gint _tmp54__length1;
	GLfloat _tmp55_;
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	_tmp0_ = fov;
	_tmp1_ = aspect;
	_tmp2_ = znear;
	_tmp3_ = zfar;
	soy_scenes_scene_perspective (_tmp0_, _tmp1_, _tmp2_, _tmp3_);
	glMatrixMode (GL_MODELVIEW);
	glClear ((GLbitfield) GL_DEPTH_BUFFER_BIT);
	glEnable (GL_DEPTH_TEST);
	glEnable (GL_LIGHTING);
	_tmp4_ = self->priv->_ambient;
	_tmp4__length1 = self->priv->_ambient_length1;
	glLightModelfv (GL_LIGHT_MODEL_AMBIENT, _tmp4_);
	_tmp5_ = self->priv->_fog;
	_tmp5__length1 = self->priv->_fog_length1;
	_tmp6_ = _tmp5_[3];
	if (_tmp6_ != ((GLfloat) 0.0f)) {
		GLfloat* _tmp7_;
		gint _tmp7__length1;
		GLfloat* _tmp8_;
		gint _tmp8__length1;
		GLfloat _tmp9_;
		glClearColor ((GLclampf) 0.5f, (GLclampf) 0.5f, (GLclampf) 0.5f, (GLclampf) 1.0f);
		glEnable (GL_FOG);
		glFogf (GL_FOG_MODE, (GLfloat) GL_EXP2);
		_tmp7_ = self->priv->_fog;
		_tmp7__length1 = self->priv->_fog_length1;
		glFogfv (GL_FOG_COLOR, _tmp7_);
		_tmp8_ = self->priv->_fog;
		_tmp8__length1 = self->priv->_fog_length1;
		_tmp9_ = _tmp8_[3];
		glFogf (GL_FOG_DENSITY, _tmp9_ / 20.0f);
		glHint (GL_FOG_HINT, GL_NICEST);
		glFogf (GL_FOG_START, (GLfloat) 1.0f);
		glFogf (GL_FOG_END, (GLfloat) 50.0f);
	}
	i = GL_LIGHT0;
	{
		GeeHashSet* _tmp10_;
		GeeIterator* _tmp11_ = NULL;
		GeeIterator* _light_it;
		_tmp10_ = self->lights;
		_tmp11_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp10_);
		_light_it = _tmp11_;
		while (TRUE) {
			GeeIterator* _tmp12_;
			gboolean _tmp13_ = FALSE;
			GeeIterator* _tmp14_;
			gpointer _tmp15_ = NULL;
			soybodiesLight* light;
			soybodiesLight* _tmp16_;
			GLenum _tmp17_;
			GLenum _tmp18_;
			_tmp12_ = _light_it;
			_tmp13_ = gee_iterator_next (_tmp12_);
			if (!_tmp13_) {
				break;
			}
			_tmp14_ = _light_it;
			_tmp15_ = gee_iterator_get (_tmp14_);
			light = (soybodiesLight*) _tmp15_;
			_tmp16_ = light;
			_tmp17_ = i;
			soy_bodies_light_on (_tmp16_, _tmp17_);
			_tmp18_ = i;
			i = _tmp18_ + 1;
			_g_object_unref0 (light);
		}
		_g_object_unref0 (_light_it);
	}
	g_rw_lock_reader_lock (&self->stepLock);
	{
		GeeHashMap* _tmp19_;
		GeeSet* _tmp20_;
		GeeSet* _tmp21_;
		GeeSet* _tmp22_;
		GeeIterator* _tmp23_ = NULL;
		GeeIterator* _tmp24_;
		GeeIterator* _d_it;
		_tmp19_ = self->bodies;
		_tmp20_ = gee_abstract_map_get_keys ((GeeMap*) _tmp19_);
		_tmp21_ = _tmp20_;
		_tmp22_ = _tmp21_;
		_tmp23_ = gee_iterable_iterator ((GeeIterable*) _tmp22_);
		_tmp24_ = _tmp23_;
		_g_object_unref0 (_tmp22_);
		_d_it = _tmp24_;
		while (TRUE) {
			GeeIterator* _tmp25_;
			gboolean _tmp26_ = FALSE;
			GeeIterator* _tmp27_;
			gpointer _tmp28_ = NULL;
			gchar* d;
			GeeHashMap* _tmp29_;
			const gchar* _tmp30_;
			gpointer _tmp31_ = NULL;
			soybodiesBody* _tmp32_;
			_tmp25_ = _d_it;
			_tmp26_ = gee_iterator_next (_tmp25_);
			if (!_tmp26_) {
				break;
			}
			_tmp27_ = _d_it;
			_tmp28_ = gee_iterator_get (_tmp27_);
			d = (gchar*) _tmp28_;
			_tmp29_ = self->bodies;
			_tmp30_ = d;
			_tmp31_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp29_, _tmp30_);
			_tmp32_ = (soybodiesBody*) _tmp31_;
			soy_bodies_body_render (_tmp32_);
			_g_object_unref0 (_tmp32_);
			_g_free0 (d);
		}
		_g_object_unref0 (_d_it);
	}
	{
		GeeArrayList* _tmp33_;
		GeeArrayList* _tmp34_;
		GeeArrayList* _joint_list;
		GeeArrayList* _tmp35_;
		gint _tmp36_;
		gint _tmp37_;
		gint _joint_size;
		gint _joint_index;
		_tmp33_ = self->joints;
		_tmp34_ = _g_object_ref0 (_tmp33_);
		_joint_list = _tmp34_;
		_tmp35_ = _joint_list;
		_tmp36_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp35_);
		_tmp37_ = _tmp36_;
		_joint_size = _tmp37_;
		_joint_index = -1;
		while (TRUE) {
			gint _tmp38_;
			gint _tmp39_;
			gint _tmp40_;
			GeeArrayList* _tmp41_;
			gint _tmp42_;
			gpointer _tmp43_ = NULL;
			soyjointsJoint* joint;
			soyjointsJoint* _tmp44_;
			_tmp38_ = _joint_index;
			_joint_index = _tmp38_ + 1;
			_tmp39_ = _joint_index;
			_tmp40_ = _joint_size;
			if (!(_tmp39_ < _tmp40_)) {
				break;
			}
			_tmp41_ = _joint_list;
			_tmp42_ = _joint_index;
			_tmp43_ = gee_abstract_list_get ((GeeAbstractList*) _tmp41_, _tmp42_);
			joint = (soyjointsJoint*) _tmp43_;
			_tmp44_ = joint;
			soy_joints_joint_render (_tmp44_);
			_g_object_unref0 (joint);
		}
		_g_object_unref0 (_joint_list);
	}
	g_rw_lock_reader_unlock (&self->stepLock);
	i = GL_LIGHT0;
	{
		GeeHashSet* _tmp45_;
		GeeIterator* _tmp46_ = NULL;
		GeeIterator* _light_it;
		_tmp45_ = self->lights;
		_tmp46_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp45_);
		_light_it = _tmp46_;
		while (TRUE) {
			GeeIterator* _tmp47_;
			gboolean _tmp48_ = FALSE;
			GeeIterator* _tmp49_;
			gpointer _tmp50_ = NULL;
			soybodiesLight* light;
			soybodiesLight* _tmp51_;
			GLenum _tmp52_;
			GLenum _tmp53_;
			_tmp47_ = _light_it;
			_tmp48_ = gee_iterator_next (_tmp47_);
			if (!_tmp48_) {
				break;
			}
			_tmp49_ = _light_it;
			_tmp50_ = gee_iterator_get (_tmp49_);
			light = (soybodiesLight*) _tmp50_;
			_tmp51_ = light;
			_tmp52_ = i;
			soy_bodies_light_off (_tmp51_, _tmp52_);
			_tmp53_ = i;
			i = _tmp53_ + 1;
			_g_object_unref0 (light);
		}
		_g_object_unref0 (_light_it);
	}
	_tmp54_ = self->priv->_fog;
	_tmp54__length1 = self->priv->_fog_length1;
	_tmp55_ = _tmp54_[3];
	if (_tmp55_ != ((GLfloat) 0.0f)) {
		glDisable (GL_FOG);
	}
	glDisable (GL_LIGHTING);
	glDisable (GL_DEPTH_TEST);
}


void soy_scenes_scene_render (soyscenesScene* self, GLfloat fov, GLfloat aspect, GLfloat znear, GLfloat zfar) {
	g_return_if_fail (self != NULL);
	SOY_SCENES_SCENE_GET_CLASS (self)->render (self, fov, aspect, znear, zfar);
}


void soy_scenes_scene_perspective (GLfloat fovy, GLfloat aspect, GLfloat zNear, GLfloat zFar) {
	GLfloat* m = NULL;
	gint m_length1 = 0;
	gint _m_size_ = 0;
	GLfloat _tmp0_;
	GLfloat _tmp1_;
	gfloat deltaZ;
	GLfloat _tmp2_;
	gfloat radians;
	gfloat _tmp3_;
	gfloat _tmp4_ = 0.0F;
	gfloat sine;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gfloat _tmp7_;
	gboolean _tmp9_;
	gboolean _tmp11_;
	gfloat _tmp12_;
	gfloat _tmp13_ = 0.0F;
	gfloat _tmp14_;
	gfloat cotangent;
	GLfloat* _tmp15_ = NULL;
	GLfloat* _tmp16_;
	gint _tmp16__length1;
	gfloat _tmp17_;
	GLfloat _tmp18_;
	GLfloat _tmp19_;
	GLfloat* _tmp20_;
	gint _tmp20__length1;
	gfloat _tmp21_;
	GLfloat _tmp22_;
	GLfloat* _tmp23_;
	gint _tmp23__length1;
	GLfloat _tmp24_;
	GLfloat _tmp25_;
	gfloat _tmp26_;
	GLfloat _tmp27_;
	GLfloat* _tmp28_;
	gint _tmp28__length1;
	GLfloat _tmp29_;
	GLfloat _tmp30_;
	gfloat _tmp31_;
	GLfloat _tmp32_;
	GLfloat* _tmp33_;
	gint _tmp33__length1;
	_tmp0_ = zFar;
	_tmp1_ = zNear;
	deltaZ = (gfloat) (_tmp0_ - _tmp1_);
	_tmp2_ = fovy;
	radians = (gfloat) (((_tmp2_ / 2.0f) * 3.141592653589793f) / 180.0f);
	_tmp3_ = radians;
	_tmp4_ = sinf (_tmp3_);
	sine = _tmp4_;
	_tmp7_ = deltaZ;
	if (_tmp7_ == 0.0f) {
		_tmp6_ = TRUE;
	} else {
		gfloat _tmp8_;
		_tmp8_ = sine;
		_tmp6_ = _tmp8_ == 0.0f;
	}
	_tmp9_ = _tmp6_;
	if (_tmp9_) {
		_tmp5_ = TRUE;
	} else {
		GLfloat _tmp10_;
		_tmp10_ = aspect;
		_tmp5_ = _tmp10_ == ((GLfloat) 0.0f);
	}
	_tmp11_ = _tmp5_;
	if (_tmp11_) {
		m = (g_free (m), NULL);
		return;
	}
	_tmp12_ = radians;
	_tmp13_ = cosf (_tmp12_);
	_tmp14_ = sine;
	cotangent = _tmp13_ / _tmp14_;
	_tmp15_ = g_new0 (GLfloat, 16);
	_tmp15_[0] = (GLfloat) 1.0f;
	_tmp15_[1] = (GLfloat) 0.0f;
	_tmp15_[2] = (GLfloat) 0.0f;
	_tmp15_[3] = (GLfloat) 0.0f;
	_tmp15_[4] = (GLfloat) 0.0f;
	_tmp15_[5] = (GLfloat) 1.0f;
	_tmp15_[6] = (GLfloat) 0.0f;
	_tmp15_[7] = (GLfloat) 0.0f;
	_tmp15_[8] = (GLfloat) 0.0f;
	_tmp15_[9] = (GLfloat) 0.0f;
	_tmp15_[10] = (GLfloat) 1.0f;
	_tmp15_[11] = (GLfloat) (-1.0f);
	_tmp15_[12] = (GLfloat) 0.0f;
	_tmp15_[13] = (GLfloat) 0.0f;
	_tmp15_[14] = (GLfloat) 0.0f;
	_tmp15_[15] = (GLfloat) 0.0f;
	m = (g_free (m), NULL);
	m = _tmp15_;
	m_length1 = 16;
	_m_size_ = m_length1;
	_tmp16_ = m;
	_tmp16__length1 = m_length1;
	_tmp17_ = cotangent;
	_tmp18_ = aspect;
	_tmp16_[0] = (GLfloat) (_tmp17_ / _tmp18_);
	_tmp19_ = _tmp16_[0];
	_tmp20_ = m;
	_tmp20__length1 = m_length1;
	_tmp21_ = cotangent;
	_tmp20_[5] = (GLfloat) _tmp21_;
	_tmp22_ = _tmp20_[5];
	_tmp23_ = m;
	_tmp23__length1 = m_length1;
	_tmp24_ = zFar;
	_tmp25_ = zNear;
	_tmp26_ = deltaZ;
	_tmp23_[10] = (-(_tmp24_ + _tmp25_)) / _tmp26_;
	_tmp27_ = _tmp23_[10];
	_tmp28_ = m;
	_tmp28__length1 = m_length1;
	_tmp29_ = zNear;
	_tmp30_ = zFar;
	_tmp31_ = deltaZ;
	_tmp28_[14] = (GLfloat) ((((-2.0f) * _tmp29_) * _tmp30_) / _tmp31_);
	_tmp32_ = _tmp28_[14];
	_tmp33_ = m;
	_tmp33__length1 = m_length1;
	glMultMatrixf (_tmp33_);
	m = (g_free (m), NULL);
}


static void __soy_scenes_scene_check_collisions_NearCallback_dnear_callback (gpointer self, struct dxGeom* o1, struct dxGeom* o2) {
	_soy_scenes_scene_check_collisions_NearCallback (self, o1, o2);
}


static void _soy_scenes_scene_check_collisions_NearCallback (soyscenesScene* self, struct dxGeom* o1, struct dxGeom* o2) {
	gboolean* _result_ = NULL;
	gint flags;
	struct dxGeom* _tmp0_;
	gulong _tmp1_ = 0UL;
	gulong cat1;
	struct dxGeom* _tmp2_;
	gulong _tmp3_ = 0UL;
	gulong cat2;
	gboolean _tmp4_ = FALSE;
	gulong _tmp5_;
	gulong _tmp6_;
	gboolean _tmp9_;
	gboolean* _tmp20_;
	struct dxGeom* _tmp21_;
	gint _tmp22_ = 0;
	struct dxGeom* _tmp23_;
	gint _tmp24_ = 0;
	dContactGeom* _tmp27_;
	dContactGeom* contactGeoms;
	struct dxGeom* _tmp28_;
	struct dxGeom* _tmp29_;
	gint _tmp30_;
	dContactGeom* _tmp31_;
	gint _tmp32_ = 0;
	gint num;
	gint _tmp33_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (o1 != NULL);
	g_return_if_fail (o2 != NULL);
	flags = 1;
	_tmp0_ = o1;
	_tmp1_ = dGeomGetCategoryBits (_tmp0_);
	cat1 = _tmp1_;
	_tmp2_ = o2;
	_tmp3_ = dGeomGetCategoryBits (_tmp2_);
	cat2 = _tmp3_;
	_tmp5_ = cat1;
	_tmp6_ = GeomIgnored;
	if ((_tmp5_ & _tmp6_) != ((gulong) 0)) {
		_tmp4_ = TRUE;
	} else {
		gulong _tmp7_;
		gulong _tmp8_;
		_tmp7_ = cat2;
		_tmp8_ = GeomIgnored;
		_tmp4_ = (_tmp7_ & _tmp8_) != ((gulong) 0);
	}
	_tmp9_ = _tmp4_;
	if (_tmp9_) {
		return;
	} else {
		struct dxGeom* _tmp10_;
		gulong _tmp11_ = 0UL;
		gulong _tmp12_;
		_tmp10_ = o1;
		_tmp11_ = dGeomGetCategoryBits (_tmp10_);
		_tmp12_ = GeomTestRay;
		if (_tmp11_ == _tmp12_) {
			struct dxGeom* _tmp13_;
			void* _tmp14_ = NULL;
			_tmp13_ = o1;
			_tmp14_ = dGeomGetData (_tmp13_);
			_result_ = (gboolean*) _tmp14_;
		} else {
			struct dxGeom* _tmp15_;
			gulong _tmp16_ = 0UL;
			gulong _tmp17_;
			_tmp15_ = o2;
			_tmp16_ = dGeomGetCategoryBits (_tmp15_);
			_tmp17_ = GeomTestRay;
			if (_tmp16_ == _tmp17_) {
				struct dxGeom* _tmp18_;
				void* _tmp19_ = NULL;
				_tmp18_ = o2;
				_tmp19_ = dGeomGetData (_tmp18_);
				_result_ = (gboolean*) _tmp19_;
			} else {
				return;
			}
		}
	}
	_tmp20_ = _result_;
	if (*_tmp20_) {
		return;
	}
	_tmp21_ = o2;
	_tmp22_ = dGeomIsSpace (_tmp21_);
	_tmp23_ = o1;
	_tmp24_ = dGeomIsSpace (_tmp23_);
	if ((_tmp22_ | _tmp24_) != 0) {
		struct dxGeom* _tmp25_;
		struct dxGeom* _tmp26_;
		_tmp25_ = o1;
		_tmp26_ = o2;
		dSpaceCollide2 (_tmp25_, self, _tmp26_, __soy_scenes_scene_check_collisions_NearCallback_dnear_callback);
	}
	_tmp27_ = dcontact_geom_array_new (1);
	contactGeoms = _tmp27_;
	_tmp28_ = o1;
	_tmp29_ = o2;
	_tmp30_ = flags;
	_tmp31_ = contactGeoms;
	_tmp32_ = dCollide (_tmp28_, _tmp29_, _tmp30_, _tmp31_, (gint) sizeof (dContactGeom));
	num = _tmp32_;
	_tmp33_ = num;
	if (_tmp33_ != 0) {
		gboolean* _tmp34_;
		gboolean _tmp35_;
		_tmp34_ = _result_;
		*_tmp34_ = TRUE;
		_tmp35_ = *_tmp34_;
	}
	return;
}


gboolean soy_scenes_scene_check_path_collision (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition* end) {
	gboolean result = FALSE;
	soyatomsPosition* _tmp0_;
	soyatomsPosition* _tmp1_;
	soyatomsPosition** _tmp2_ = NULL;
	soyatomsPosition** ends;
	gint ends_length1;
	gint _ends_size_;
	soyatomsPosition* _tmp3_;
	gint _tmp4_ = 0;
	gboolean* _tmp5_ = NULL;
	gboolean* _tmp6_;
	gint _tmp6__length1;
	gboolean _tmp7_;
	gboolean _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (start != NULL, FALSE);
	g_return_val_if_fail (end != NULL, FALSE);
	_tmp0_ = end;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_tmp2_ = g_new0 (soyatomsPosition*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	ends = _tmp2_;
	ends_length1 = 1;
	_ends_size_ = ends_length1;
	_tmp3_ = start;
	_tmp5_ = soy_scenes_scene_check_collisions (self, _tmp3_, ends, ends_length1, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp6__length1 = _tmp4_;
	_tmp7_ = _tmp6_[0];
	_tmp8_ = _tmp7_;
	_tmp6_ = (g_free (_tmp6_), NULL);
	result = _tmp8_;
	ends = (_vala_array_free (ends, ends_length1, (GDestroyNotify) g_object_unref), NULL);
	return result;
}


gboolean* soy_scenes_scene_check_collisions (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition** ends, int ends_length1, int* result_length1) {
	gboolean* result = NULL;
	soyatomsPosition** _tmp0_;
	gint _tmp0__length1;
	gboolean* _tmp1_ = NULL;
	gboolean* ret;
	gint ret_length1;
	gint _ret_size_;
	soyatomsPosition** _tmp2_;
	gint _tmp2__length1;
	struct dxGeom** _tmp3_ = NULL;
	struct dxGeom** geoms;
	gint geoms_length1;
	gint _geoms_size_;
	gulong _tmp4_;
	gulong category_bits;
	gulong _tmp5_;
	gulong _tmp6_;
	gulong collide_bits;
	struct dxSpace* _tmp70_;
	struct dxGeom** _tmp71_;
	gint _tmp71__length1;
	gboolean* _tmp73_;
	gint _tmp73__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (start != NULL, NULL);
	_tmp0_ = ends;
	_tmp0__length1 = ends_length1;
	_tmp1_ = g_new0 (gboolean, _tmp0__length1);
	ret = _tmp1_;
	ret_length1 = _tmp0__length1;
	_ret_size_ = ret_length1;
	_tmp2_ = ends;
	_tmp2__length1 = ends_length1;
	_tmp3_ = g_new0 (struct dxGeom*, _tmp2__length1);
	geoms = _tmp3_;
	geoms_length1 = _tmp2__length1;
	_geoms_size_ = geoms_length1;
	_tmp4_ = GeomTestRay;
	category_bits = _tmp4_;
	_tmp5_ = category_bits;
	_tmp6_ = GeomIgnored;
	collide_bits = ~(_tmp5_ | _tmp6_);
	g_rw_lock_writer_lock (&self->stepLock);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_;
				soyatomsPosition** _tmp10_;
				gint _tmp10__length1;
				gboolean* _tmp11_;
				gint _tmp11__length1;
				gint _tmp12_;
				gboolean _tmp13_;
				soyatomsPosition** _tmp14_;
				gint _tmp14__length1;
				gint _tmp15_;
				soyatomsPosition* _tmp16_;
				gfloat _tmp17_;
				gfloat _tmp18_;
				soyatomsPosition* _tmp19_;
				gfloat _tmp20_;
				gfloat _tmp21_;
				gfloat dx;
				soyatomsPosition** _tmp22_;
				gint _tmp22__length1;
				gint _tmp23_;
				soyatomsPosition* _tmp24_;
				gfloat _tmp25_;
				gfloat _tmp26_;
				soyatomsPosition* _tmp27_;
				gfloat _tmp28_;
				gfloat _tmp29_;
				gfloat dy;
				soyatomsPosition** _tmp30_;
				gint _tmp30__length1;
				gint _tmp31_;
				soyatomsPosition* _tmp32_;
				gfloat _tmp33_;
				gfloat _tmp34_;
				soyatomsPosition* _tmp35_;
				gfloat _tmp36_;
				gfloat _tmp37_;
				gfloat dz;
				gfloat _tmp38_;
				gfloat _tmp39_;
				gfloat _tmp40_ = 0.0F;
				gfloat _tmp41_;
				gfloat _tmp42_ = 0.0F;
				dReal dist;
				struct dxSpace* _tmp43_;
				dReal _tmp44_;
				struct dxGeom* _tmp45_;
				struct dxGeom* ray;
				struct dxGeom* _tmp46_;
				soyatomsPosition* _tmp47_;
				gfloat _tmp48_;
				gfloat _tmp49_;
				soyatomsPosition* _tmp50_;
				gfloat _tmp51_;
				gfloat _tmp52_;
				soyatomsPosition* _tmp53_;
				gfloat _tmp54_;
				gfloat _tmp55_;
				gfloat _tmp56_;
				gfloat _tmp57_;
				gfloat _tmp58_;
				struct dxGeom* _tmp59_;
				gulong _tmp60_;
				struct dxGeom* _tmp61_;
				gulong _tmp62_;
				struct dxGeom* _tmp63_;
				gboolean* _tmp64_;
				gint _tmp64__length1;
				gint _tmp65_;
				struct dxGeom** _tmp66_;
				gint _tmp66__length1;
				gint _tmp67_;
				struct dxGeom* _tmp68_;
				struct dxGeom* _tmp69_;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gint _tmp9_;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp10_ = ends;
				_tmp10__length1 = ends_length1;
				if (!(i <= (_tmp10__length1 - 1))) {
					break;
				}
				_tmp11_ = ret;
				_tmp11__length1 = ret_length1;
				_tmp12_ = i;
				_tmp11_[_tmp12_] = FALSE;
				_tmp13_ = _tmp11_[_tmp12_];
				_tmp14_ = ends;
				_tmp14__length1 = ends_length1;
				_tmp15_ = i;
				_tmp16_ = _tmp14_[_tmp15_];
				_tmp17_ = soy_atoms_position_get_x (_tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = start;
				_tmp20_ = soy_atoms_position_get_x (_tmp19_);
				_tmp21_ = _tmp20_;
				dx = _tmp18_ - _tmp21_;
				_tmp22_ = ends;
				_tmp22__length1 = ends_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				_tmp25_ = soy_atoms_position_get_y (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = start;
				_tmp28_ = soy_atoms_position_get_y (_tmp27_);
				_tmp29_ = _tmp28_;
				dy = _tmp26_ - _tmp29_;
				_tmp30_ = ends;
				_tmp30__length1 = ends_length1;
				_tmp31_ = i;
				_tmp32_ = _tmp30_[_tmp31_];
				_tmp33_ = soy_atoms_position_get_z (_tmp32_);
				_tmp34_ = _tmp33_;
				_tmp35_ = start;
				_tmp36_ = soy_atoms_position_get_z (_tmp35_);
				_tmp37_ = _tmp36_;
				dz = _tmp34_ - _tmp37_;
				_tmp38_ = dx;
				_tmp39_ = dy;
				_tmp40_ = hypotf (_tmp38_, _tmp39_);
				_tmp41_ = dz;
				_tmp42_ = hypotf (_tmp40_, _tmp41_);
				dist = (dReal) _tmp42_;
				_tmp43_ = self->space;
				_tmp44_ = dist;
				_tmp45_ = dCreateRay (_tmp43_, _tmp44_);
				ray = _tmp45_;
				_tmp46_ = ray;
				_tmp47_ = start;
				_tmp48_ = soy_atoms_position_get_x (_tmp47_);
				_tmp49_ = _tmp48_;
				_tmp50_ = start;
				_tmp51_ = soy_atoms_position_get_y (_tmp50_);
				_tmp52_ = _tmp51_;
				_tmp53_ = start;
				_tmp54_ = soy_atoms_position_get_z (_tmp53_);
				_tmp55_ = _tmp54_;
				_tmp56_ = dx;
				_tmp57_ = dy;
				_tmp58_ = dz;
				dGeomRaySet (_tmp46_, (dReal) _tmp49_, (dReal) _tmp52_, (dReal) _tmp55_, (dReal) _tmp56_, (dReal) _tmp57_, (dReal) _tmp58_);
				_tmp59_ = ray;
				_tmp60_ = collide_bits;
				dGeomSetCollideBits (_tmp59_, _tmp60_);
				_tmp61_ = ray;
				_tmp62_ = category_bits;
				dGeomSetCategoryBits (_tmp61_, _tmp62_);
				_tmp63_ = ray;
				_tmp64_ = ret;
				_tmp64__length1 = ret_length1;
				_tmp65_ = i;
				dGeomSetData (_tmp63_, (void*) (&_tmp64_[_tmp65_]));
				_tmp66_ = geoms;
				_tmp66__length1 = geoms_length1;
				_tmp67_ = i;
				_tmp68_ = ray;
				_tmp66_[_tmp67_] = _tmp68_;
				_tmp69_ = _tmp66_[_tmp67_];
			}
		}
	}
	_tmp70_ = self->space;
	dSpaceCollide (_tmp70_, self, __soy_scenes_scene_check_collisions_NearCallback_dnear_callback);
	_tmp71_ = geoms;
	_tmp71__length1 = geoms_length1;
	{
		struct dxGeom** i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp71_;
		i_collection_length1 = _tmp71__length1;
		for (i_it = 0; i_it < _tmp71__length1; i_it = i_it + 1) {
			struct dxGeom* i = NULL;
			i = i_collection[i_it];
			{
				struct dxGeom* _tmp72_;
				_tmp72_ = i;
				dGeomDestroy (_tmp72_);
			}
		}
	}
	g_rw_lock_writer_unlock (&self->stepLock);
	_tmp73_ = ret;
	_tmp73__length1 = ret_length1;
	if (result_length1) {
		*result_length1 = _tmp73__length1;
	}
	result = _tmp73_;
	geoms = (g_free (geoms), NULL);
	return result;
}


gboolean* soy_scenes_scene_check_collisions_with_radius (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition** ends, int ends_length1, gfloat radius, int* result_length1) {
	gboolean* result = NULL;
	soyatomsPosition** _tmp0_;
	gint _tmp0__length1;
	gboolean* _tmp1_ = NULL;
	gboolean* ret;
	gint ret_length1;
	gint _ret_size_;
	soyatomsPosition** _tmp2_;
	gint _tmp2__length1;
	struct dxGeom** _tmp3_ = NULL;
	struct dxGeom** geoms;
	gint geoms_length1;
	gint _geoms_size_;
	gulong _tmp4_;
	gulong category_bits;
	gulong _tmp5_;
	gulong _tmp6_;
	gulong collide_bits;
	struct dxSpace* _tmp111_;
	struct dxGeom** _tmp112_;
	gint _tmp112__length1;
	gboolean* _tmp114_;
	gint _tmp114__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (start != NULL, NULL);
	_tmp0_ = ends;
	_tmp0__length1 = ends_length1;
	_tmp1_ = g_new0 (gboolean, _tmp0__length1);
	ret = _tmp1_;
	ret_length1 = _tmp0__length1;
	_ret_size_ = ret_length1;
	_tmp2_ = ends;
	_tmp2__length1 = ends_length1;
	_tmp3_ = g_new0 (struct dxGeom*, _tmp2__length1);
	geoms = _tmp3_;
	geoms_length1 = _tmp2__length1;
	_geoms_size_ = geoms_length1;
	_tmp4_ = GeomTestRay;
	category_bits = _tmp4_;
	_tmp5_ = category_bits;
	_tmp6_ = GeomIgnored;
	collide_bits = ~(_tmp5_ | _tmp6_);
	g_rw_lock_writer_lock (&self->stepLock);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_;
				soyatomsPosition** _tmp10_;
				gint _tmp10__length1;
				gboolean* _tmp11_;
				gint _tmp11__length1;
				gint _tmp12_;
				gboolean _tmp13_;
				soyatomsPosition** _tmp14_;
				gint _tmp14__length1;
				gint _tmp15_;
				soyatomsPosition* _tmp16_;
				soyatomsPosition* _tmp17_;
				soyatomsPosition* end;
				soyatomsPosition* _tmp18_;
				gfloat _tmp19_;
				gfloat _tmp20_;
				soyatomsPosition* _tmp21_;
				gfloat _tmp22_;
				gfloat _tmp23_;
				soyatomsPosition* _tmp24_;
				gfloat _tmp25_;
				gfloat _tmp26_;
				soyatomsPosition* _tmp27_;
				gfloat _tmp28_;
				gfloat _tmp29_;
				gfloat _tmp30_ = 0.0F;
				soyatomsPosition* _tmp31_;
				gfloat _tmp32_;
				gfloat _tmp33_;
				soyatomsPosition* _tmp34_;
				gfloat _tmp35_;
				gfloat _tmp36_;
				gfloat _tmp37_ = 0.0F;
				gfloat dist;
				soyatomsPosition* _tmp38_;
				gfloat _tmp39_;
				gfloat _tmp40_;
				soyatomsPosition* _tmp41_;
				gfloat _tmp42_;
				gfloat _tmp43_;
				gfloat _tmp44_;
				gfloat _tmp45_ = 0.0F;
				gfloat angle;
				gfloat _tmp46_;
				soyatomsPosition* _tmp47_;
				gfloat _tmp48_;
				gfloat _tmp49_;
				soyatomsPosition* _tmp50_;
				gfloat _tmp51_;
				gfloat _tmp52_;
				gfloat axis_x;
				gfloat _tmp53_;
				soyatomsPosition* _tmp54_;
				gfloat _tmp55_;
				gfloat _tmp56_;
				soyatomsPosition* _tmp57_;
				gfloat _tmp58_;
				gfloat _tmp59_;
				gfloat axis_y;
				gfloat axis_z;
				struct dxSpace* _tmp60_;
				gfloat _tmp61_;
				gfloat _tmp62_;
				struct dxGeom* _tmp63_;
				struct dxGeom* cap;
				struct dxGeom* _tmp64_;
				soyatomsPosition* _tmp65_;
				gfloat _tmp66_;
				gfloat _tmp67_;
				soyatomsPosition* _tmp68_;
				gfloat _tmp69_;
				gfloat _tmp70_;
				soyatomsPosition* _tmp71_;
				gfloat _tmp72_;
				gfloat _tmp73_;
				soyatomsPosition* _tmp74_;
				gfloat _tmp75_;
				gfloat _tmp76_;
				soyatomsPosition* _tmp77_;
				gfloat _tmp78_;
				gfloat _tmp79_;
				soyatomsPosition* _tmp80_;
				gfloat _tmp81_;
				gfloat _tmp82_;
				soyatomsPosition* _tmp83_;
				gfloat _tmp84_;
				gfloat _tmp85_;
				soyatomsPosition* _tmp86_;
				gfloat _tmp87_;
				gfloat _tmp88_;
				soyatomsPosition* _tmp89_;
				gfloat _tmp90_;
				gfloat _tmp91_;
				dxMatrix3* _tmp92_;
				dxMatrix3* rot;
				dxMatrix3* _tmp93_;
				gfloat _tmp94_;
				gfloat _tmp95_;
				gfloat _tmp96_;
				gfloat _tmp97_;
				struct dxGeom* _tmp98_;
				dxMatrix3* _tmp99_;
				struct dxGeom* _tmp100_;
				gulong _tmp101_;
				struct dxGeom* _tmp102_;
				gulong _tmp103_;
				struct dxGeom* _tmp104_;
				gboolean* _tmp105_;
				gint _tmp105__length1;
				gint _tmp106_;
				struct dxGeom** _tmp107_;
				gint _tmp107__length1;
				gint _tmp108_;
				struct dxGeom* _tmp109_;
				struct dxGeom* _tmp110_;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gint _tmp9_;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp10_ = ends;
				_tmp10__length1 = ends_length1;
				if (!(i <= (_tmp10__length1 - 1))) {
					break;
				}
				_tmp11_ = ret;
				_tmp11__length1 = ret_length1;
				_tmp12_ = i;
				_tmp11_[_tmp12_] = FALSE;
				_tmp13_ = _tmp11_[_tmp12_];
				_tmp14_ = ends;
				_tmp14__length1 = ends_length1;
				_tmp15_ = i;
				_tmp16_ = _tmp14_[_tmp15_];
				_tmp17_ = _g_object_ref0 (_tmp16_);
				end = _tmp17_;
				_tmp18_ = end;
				_tmp19_ = soy_atoms_position_get_x (_tmp18_);
				_tmp20_ = _tmp19_;
				_tmp21_ = start;
				_tmp22_ = soy_atoms_position_get_x (_tmp21_);
				_tmp23_ = _tmp22_;
				_tmp24_ = end;
				_tmp25_ = soy_atoms_position_get_y (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = start;
				_tmp28_ = soy_atoms_position_get_y (_tmp27_);
				_tmp29_ = _tmp28_;
				_tmp30_ = hypotf (_tmp20_ - _tmp23_, _tmp26_ - _tmp29_);
				_tmp31_ = end;
				_tmp32_ = soy_atoms_position_get_z (_tmp31_);
				_tmp33_ = _tmp32_;
				_tmp34_ = start;
				_tmp35_ = soy_atoms_position_get_z (_tmp34_);
				_tmp36_ = _tmp35_;
				_tmp37_ = hypotf (_tmp30_, _tmp33_ - _tmp36_);
				dist = _tmp37_;
				_tmp38_ = end;
				_tmp39_ = soy_atoms_position_get_z (_tmp38_);
				_tmp40_ = _tmp39_;
				_tmp41_ = start;
				_tmp42_ = soy_atoms_position_get_z (_tmp41_);
				_tmp43_ = _tmp42_;
				_tmp44_ = dist;
				_tmp45_ = acosf ((_tmp40_ - _tmp43_) / _tmp44_);
				angle = _tmp45_;
				_tmp46_ = dist;
				_tmp47_ = end;
				_tmp48_ = soy_atoms_position_get_y (_tmp47_);
				_tmp49_ = _tmp48_;
				_tmp50_ = start;
				_tmp51_ = soy_atoms_position_get_y (_tmp50_);
				_tmp52_ = _tmp51_;
				axis_x = -(_tmp46_ * (_tmp49_ - _tmp52_));
				_tmp53_ = dist;
				_tmp54_ = end;
				_tmp55_ = soy_atoms_position_get_x (_tmp54_);
				_tmp56_ = _tmp55_;
				_tmp57_ = start;
				_tmp58_ = soy_atoms_position_get_x (_tmp57_);
				_tmp59_ = _tmp58_;
				axis_y = _tmp53_ * (_tmp56_ - _tmp59_);
				axis_z = (gfloat) 0;
				_tmp60_ = self->space;
				_tmp61_ = radius;
				_tmp62_ = dist;
				_tmp63_ = dCreateCapsule (_tmp60_, (dReal) _tmp61_, (dReal) _tmp62_);
				cap = _tmp63_;
				_tmp64_ = cap;
				_tmp65_ = start;
				_tmp66_ = soy_atoms_position_get_x (_tmp65_);
				_tmp67_ = _tmp66_;
				_tmp68_ = end;
				_tmp69_ = soy_atoms_position_get_x (_tmp68_);
				_tmp70_ = _tmp69_;
				_tmp71_ = start;
				_tmp72_ = soy_atoms_position_get_x (_tmp71_);
				_tmp73_ = _tmp72_;
				_tmp74_ = start;
				_tmp75_ = soy_atoms_position_get_y (_tmp74_);
				_tmp76_ = _tmp75_;
				_tmp77_ = end;
				_tmp78_ = soy_atoms_position_get_y (_tmp77_);
				_tmp79_ = _tmp78_;
				_tmp80_ = start;
				_tmp81_ = soy_atoms_position_get_y (_tmp80_);
				_tmp82_ = _tmp81_;
				_tmp83_ = start;
				_tmp84_ = soy_atoms_position_get_z (_tmp83_);
				_tmp85_ = _tmp84_;
				_tmp86_ = end;
				_tmp87_ = soy_atoms_position_get_z (_tmp86_);
				_tmp88_ = _tmp87_;
				_tmp89_ = start;
				_tmp90_ = soy_atoms_position_get_z (_tmp89_);
				_tmp91_ = _tmp90_;
				dGeomSetPosition (_tmp64_, (dReal) (_tmp67_ + ((_tmp70_ - _tmp73_) / 2.0f)), (dReal) (_tmp76_ + ((_tmp79_ - _tmp82_) / 2.0f)), (dReal) (_tmp85_ + ((_tmp88_ - _tmp91_) / 2.0f)));
				_tmp92_ = dmatrix3_new ();
				rot = _tmp92_;
				_tmp93_ = rot;
				_tmp94_ = axis_x;
				_tmp95_ = axis_y;
				_tmp96_ = axis_z;
				_tmp97_ = angle;
				dRFromAxisAndAngle (_tmp93_, (dReal) _tmp94_, (dReal) _tmp95_, (dReal) _tmp96_, (dReal) _tmp97_);
				_tmp98_ = cap;
				_tmp99_ = rot;
				dGeomSetRotation (_tmp98_, _tmp99_);
				_tmp100_ = cap;
				_tmp101_ = collide_bits;
				dGeomSetCollideBits (_tmp100_, _tmp101_);
				_tmp102_ = cap;
				_tmp103_ = category_bits;
				dGeomSetCategoryBits (_tmp102_, _tmp103_);
				_tmp104_ = cap;
				_tmp105_ = ret;
				_tmp105__length1 = ret_length1;
				_tmp106_ = i;
				dGeomSetData (_tmp104_, (void*) (&_tmp105_[_tmp106_]));
				_tmp107_ = geoms;
				_tmp107__length1 = geoms_length1;
				_tmp108_ = i;
				_tmp109_ = cap;
				_tmp107_[_tmp108_] = _tmp109_;
				_tmp110_ = _tmp107_[_tmp108_];
				_dmatrix3_free0 (rot);
				_g_object_unref0 (end);
			}
		}
	}
	_tmp111_ = self->space;
	dSpaceCollide (_tmp111_, self, __soy_scenes_scene_check_collisions_NearCallback_dnear_callback);
	_tmp112_ = geoms;
	_tmp112__length1 = geoms_length1;
	{
		struct dxGeom** i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp112_;
		i_collection_length1 = _tmp112__length1;
		for (i_it = 0; i_it < _tmp112__length1; i_it = i_it + 1) {
			struct dxGeom* i = NULL;
			i = i_collection[i_it];
			{
				struct dxGeom* _tmp113_;
				_tmp113_ = i;
				dGeomDestroy (_tmp113_);
			}
		}
	}
	g_rw_lock_writer_unlock (&self->stepLock);
	_tmp114_ = ret;
	_tmp114__length1 = ret_length1;
	if (result_length1) {
		*result_length1 = _tmp114__length1;
	}
	result = _tmp114_;
	geoms = (g_free (geoms), NULL);
	return result;
}


gboolean* soy_scenes_scene_check_collisions_with_size (soyscenesScene* self, soyatomsPosition* start, soyatomsPosition** ends, int ends_length1, soyatomsSize* aabb, int* result_length1) {
	gboolean* result = NULL;
	soyatomsPosition** _tmp0_;
	gint _tmp0__length1;
	gboolean* _tmp1_ = NULL;
	gboolean* ret;
	gint ret_length1;
	gint _ret_size_;
	gboolean start_bool;
	soyatomsPosition** _tmp2_;
	gint _tmp2__length1;
	struct dxGeom** _tmp3_ = NULL;
	struct dxGeom** geoms;
	gint geoms_length1;
	gint _geoms_size_;
	gulong _tmp4_;
	gulong category_bits;
	gulong _tmp5_;
	gulong _tmp6_;
	gulong collide_bits;
	soyatomsSize* _tmp7_;
	gfloat _tmp8_;
	gfloat _tmp9_;
	gfloat x;
	soyatomsSize* _tmp10_;
	gfloat _tmp11_;
	gfloat _tmp12_;
	gfloat y;
	soyatomsSize* _tmp13_;
	gfloat _tmp14_;
	gfloat _tmp15_;
	gfloat z;
	gfloat _tmp16_;
	gfloat _tmp17_;
	gfloat _tmp18_ = 0.0F;
	gfloat size_y;
	gfloat _tmp19_;
	gfloat _tmp20_;
	gfloat _tmp21_ = 0.0F;
	gfloat size_z;
	struct dxSpace* _tmp22_;
	gfloat _tmp23_;
	gfloat _tmp24_;
	gfloat _tmp25_;
	struct dxGeom* _tmp26_;
	struct dxGeom* box_start;
	struct dxGeom* _tmp27_;
	soyatomsPosition* _tmp28_;
	gfloat _tmp29_;
	gfloat _tmp30_;
	soyatomsPosition* _tmp31_;
	gfloat _tmp32_;
	gfloat _tmp33_;
	soyatomsPosition* _tmp34_;
	gfloat _tmp35_;
	gfloat _tmp36_;
	struct dxGeom* _tmp37_;
	gulong _tmp38_;
	struct dxGeom* _tmp39_;
	gulong _tmp40_;
	struct dxGeom* _tmp41_;
	struct dxSpace* _tmp173_;
	struct dxGeom* _tmp174_;
	struct dxGeom** _tmp175_;
	gint _tmp175__length1;
	gboolean _tmp177_;
	gboolean* _tmp185_;
	gint _tmp185__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (start != NULL, NULL);
	g_return_val_if_fail (aabb != NULL, NULL);
	_tmp0_ = ends;
	_tmp0__length1 = ends_length1;
	_tmp1_ = g_new0 (gboolean, _tmp0__length1);
	ret = _tmp1_;
	ret_length1 = _tmp0__length1;
	_ret_size_ = ret_length1;
	start_bool = FALSE;
	_tmp2_ = ends;
	_tmp2__length1 = ends_length1;
	_tmp3_ = g_new0 (struct dxGeom*, 2 * _tmp2__length1);
	geoms = _tmp3_;
	geoms_length1 = 2 * _tmp2__length1;
	_geoms_size_ = geoms_length1;
	_tmp4_ = GeomTestRay;
	category_bits = _tmp4_;
	_tmp5_ = category_bits;
	_tmp6_ = GeomIgnored;
	collide_bits = ~(_tmp5_ | _tmp6_);
	_tmp7_ = aabb;
	_tmp8_ = soy_atoms_size_get_width (_tmp7_);
	_tmp9_ = _tmp8_;
	x = (gfloat) _tmp9_;
	_tmp10_ = aabb;
	_tmp11_ = soy_atoms_size_get_height (_tmp10_);
	_tmp12_ = _tmp11_;
	y = (gfloat) _tmp12_;
	_tmp13_ = aabb;
	_tmp14_ = soy_atoms_size_get_depth (_tmp13_);
	_tmp15_ = _tmp14_;
	z = (gfloat) _tmp15_;
	_tmp16_ = x;
	_tmp17_ = y;
	_tmp18_ = hypotf (_tmp16_, _tmp17_);
	size_y = _tmp18_;
	_tmp19_ = x;
	_tmp20_ = z;
	_tmp21_ = hypotf (_tmp19_, _tmp20_);
	size_z = _tmp21_;
	g_rw_lock_writer_lock (&self->stepLock);
	_tmp22_ = self->space;
	_tmp23_ = x;
	_tmp24_ = y;
	_tmp25_ = z;
	_tmp26_ = dCreateBox (_tmp22_, (dReal) _tmp23_, (dReal) _tmp24_, (dReal) _tmp25_);
	box_start = _tmp26_;
	_tmp27_ = box_start;
	_tmp28_ = start;
	_tmp29_ = soy_atoms_position_get_x (_tmp28_);
	_tmp30_ = _tmp29_;
	_tmp31_ = start;
	_tmp32_ = soy_atoms_position_get_y (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = start;
	_tmp35_ = soy_atoms_position_get_z (_tmp34_);
	_tmp36_ = _tmp35_;
	dGeomSetPosition (_tmp27_, (dReal) _tmp30_, (dReal) _tmp33_, (dReal) _tmp36_);
	_tmp37_ = box_start;
	_tmp38_ = collide_bits;
	dGeomSetCollideBits (_tmp37_, _tmp38_);
	_tmp39_ = box_start;
	_tmp40_ = category_bits;
	dGeomSetCategoryBits (_tmp39_, _tmp40_);
	_tmp41_ = box_start;
	dGeomSetData (_tmp41_, (void*) (&start_bool));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp42_;
			_tmp42_ = TRUE;
			while (TRUE) {
				gboolean _tmp43_;
				soyatomsPosition** _tmp45_;
				gint _tmp45__length1;
				gboolean* _tmp46_;
				gint _tmp46__length1;
				gint _tmp47_;
				gboolean _tmp48_;
				soyatomsPosition** _tmp49_;
				gint _tmp49__length1;
				gint _tmp50_;
				soyatomsPosition* _tmp51_;
				soyatomsPosition* _tmp52_;
				soyatomsPosition* end;
				soyatomsPosition* _tmp53_;
				gfloat _tmp54_;
				gfloat _tmp55_;
				soyatomsPosition* _tmp56_;
				gfloat _tmp57_;
				gfloat _tmp58_;
				soyatomsPosition* _tmp59_;
				gfloat _tmp60_;
				gfloat _tmp61_;
				soyatomsPosition* _tmp62_;
				gfloat _tmp63_;
				gfloat _tmp64_;
				gfloat _tmp65_ = 0.0F;
				soyatomsPosition* _tmp66_;
				gfloat _tmp67_;
				gfloat _tmp68_;
				soyatomsPosition* _tmp69_;
				gfloat _tmp70_;
				gfloat _tmp71_;
				gfloat _tmp72_ = 0.0F;
				gfloat dist;
				soyatomsPosition* _tmp73_;
				gfloat _tmp74_;
				gfloat _tmp75_;
				soyatomsPosition* _tmp76_;
				gfloat _tmp77_;
				gfloat _tmp78_;
				gfloat _tmp79_;
				gfloat _tmp80_ = 0.0F;
				gfloat angle;
				gfloat axis_x;
				gfloat _tmp81_;
				soyatomsPosition* _tmp82_;
				gfloat _tmp83_;
				gfloat _tmp84_;
				soyatomsPosition* _tmp85_;
				gfloat _tmp86_;
				gfloat _tmp87_;
				gfloat axis_y;
				gfloat _tmp88_;
				soyatomsPosition* _tmp89_;
				gfloat _tmp90_;
				gfloat _tmp91_;
				soyatomsPosition* _tmp92_;
				gfloat _tmp93_;
				gfloat _tmp94_;
				gfloat axis_z;
				struct dxSpace* _tmp95_;
				gfloat _tmp96_;
				gfloat _tmp97_;
				gfloat _tmp98_;
				struct dxGeom* _tmp99_;
				struct dxGeom* box_end;
				struct dxSpace* _tmp100_;
				gfloat _tmp101_;
				gfloat _tmp102_;
				gfloat _tmp103_;
				struct dxGeom* _tmp104_;
				struct dxGeom* middle;
				struct dxGeom* _tmp105_;
				soyatomsPosition* _tmp106_;
				gfloat _tmp107_;
				gfloat _tmp108_;
				soyatomsPosition* _tmp109_;
				gfloat _tmp110_;
				gfloat _tmp111_;
				soyatomsPosition* _tmp112_;
				gfloat _tmp113_;
				gfloat _tmp114_;
				struct dxGeom* _tmp115_;
				soyatomsPosition* _tmp116_;
				gfloat _tmp117_;
				gfloat _tmp118_;
				soyatomsPosition* _tmp119_;
				gfloat _tmp120_;
				gfloat _tmp121_;
				soyatomsPosition* _tmp122_;
				gfloat _tmp123_;
				gfloat _tmp124_;
				soyatomsPosition* _tmp125_;
				gfloat _tmp126_;
				gfloat _tmp127_;
				soyatomsPosition* _tmp128_;
				gfloat _tmp129_;
				gfloat _tmp130_;
				soyatomsPosition* _tmp131_;
				gfloat _tmp132_;
				gfloat _tmp133_;
				soyatomsPosition* _tmp134_;
				gfloat _tmp135_;
				gfloat _tmp136_;
				soyatomsPosition* _tmp137_;
				gfloat _tmp138_;
				gfloat _tmp139_;
				soyatomsPosition* _tmp140_;
				gfloat _tmp141_;
				gfloat _tmp142_;
				dxMatrix3* _tmp143_;
				dxMatrix3* rot;
				dxMatrix3* _tmp144_;
				gfloat _tmp145_;
				gfloat _tmp146_;
				gfloat _tmp147_;
				gfloat _tmp148_;
				struct dxGeom* _tmp149_;
				dxMatrix3* _tmp150_;
				struct dxGeom* _tmp151_;
				gulong _tmp152_;
				struct dxGeom* _tmp153_;
				gulong _tmp154_;
				struct dxGeom* _tmp155_;
				gulong _tmp156_;
				struct dxGeom* _tmp157_;
				gulong _tmp158_;
				struct dxGeom* _tmp159_;
				gboolean* _tmp160_;
				gint _tmp160__length1;
				gint _tmp161_;
				struct dxGeom* _tmp162_;
				gboolean* _tmp163_;
				gint _tmp163__length1;
				gint _tmp164_;
				struct dxGeom** _tmp165_;
				gint _tmp165__length1;
				gint _tmp166_;
				struct dxGeom* _tmp167_;
				struct dxGeom* _tmp168_;
				struct dxGeom** _tmp169_;
				gint _tmp169__length1;
				gint _tmp170_;
				struct dxGeom* _tmp171_;
				struct dxGeom* _tmp172_;
				_tmp43_ = _tmp42_;
				if (!_tmp43_) {
					gint _tmp44_;
					_tmp44_ = i;
					i = _tmp44_ + 1;
				}
				_tmp42_ = FALSE;
				_tmp45_ = ends;
				_tmp45__length1 = ends_length1;
				if (!(i <= (_tmp45__length1 - 1))) {
					break;
				}
				_tmp46_ = ret;
				_tmp46__length1 = ret_length1;
				_tmp47_ = i;
				_tmp46_[_tmp47_] = FALSE;
				_tmp48_ = _tmp46_[_tmp47_];
				_tmp49_ = ends;
				_tmp49__length1 = ends_length1;
				_tmp50_ = i;
				_tmp51_ = _tmp49_[_tmp50_];
				_tmp52_ = _g_object_ref0 (_tmp51_);
				end = _tmp52_;
				_tmp53_ = end;
				_tmp54_ = soy_atoms_position_get_x (_tmp53_);
				_tmp55_ = _tmp54_;
				_tmp56_ = start;
				_tmp57_ = soy_atoms_position_get_x (_tmp56_);
				_tmp58_ = _tmp57_;
				_tmp59_ = end;
				_tmp60_ = soy_atoms_position_get_y (_tmp59_);
				_tmp61_ = _tmp60_;
				_tmp62_ = start;
				_tmp63_ = soy_atoms_position_get_y (_tmp62_);
				_tmp64_ = _tmp63_;
				_tmp65_ = hypotf (_tmp55_ - _tmp58_, _tmp61_ - _tmp64_);
				_tmp66_ = end;
				_tmp67_ = soy_atoms_position_get_z (_tmp66_);
				_tmp68_ = _tmp67_;
				_tmp69_ = start;
				_tmp70_ = soy_atoms_position_get_z (_tmp69_);
				_tmp71_ = _tmp70_;
				_tmp72_ = hypotf (_tmp65_, _tmp68_ - _tmp71_);
				dist = _tmp72_;
				_tmp73_ = end;
				_tmp74_ = soy_atoms_position_get_x (_tmp73_);
				_tmp75_ = _tmp74_;
				_tmp76_ = start;
				_tmp77_ = soy_atoms_position_get_x (_tmp76_);
				_tmp78_ = _tmp77_;
				_tmp79_ = dist;
				_tmp80_ = acosf ((_tmp75_ - _tmp78_) / _tmp79_);
				angle = _tmp80_;
				axis_x = (gfloat) 0;
				_tmp81_ = dist;
				_tmp82_ = end;
				_tmp83_ = soy_atoms_position_get_z (_tmp82_);
				_tmp84_ = _tmp83_;
				_tmp85_ = start;
				_tmp86_ = soy_atoms_position_get_z (_tmp85_);
				_tmp87_ = _tmp86_;
				axis_y = -(_tmp81_ * (_tmp84_ - _tmp87_));
				_tmp88_ = dist;
				_tmp89_ = end;
				_tmp90_ = soy_atoms_position_get_y (_tmp89_);
				_tmp91_ = _tmp90_;
				_tmp92_ = start;
				_tmp93_ = soy_atoms_position_get_y (_tmp92_);
				_tmp94_ = _tmp93_;
				axis_z = _tmp88_ * (_tmp91_ - _tmp94_);
				_tmp95_ = self->space;
				_tmp96_ = x;
				_tmp97_ = y;
				_tmp98_ = z;
				_tmp99_ = dCreateBox (_tmp95_, (dReal) _tmp96_, (dReal) _tmp97_, (dReal) _tmp98_);
				box_end = _tmp99_;
				_tmp100_ = self->space;
				_tmp101_ = dist;
				_tmp102_ = size_y;
				_tmp103_ = size_z;
				_tmp104_ = dCreateBox (_tmp100_, (dReal) _tmp101_, (dReal) _tmp102_, (dReal) _tmp103_);
				middle = _tmp104_;
				_tmp105_ = box_end;
				_tmp106_ = end;
				_tmp107_ = soy_atoms_position_get_x (_tmp106_);
				_tmp108_ = _tmp107_;
				_tmp109_ = end;
				_tmp110_ = soy_atoms_position_get_y (_tmp109_);
				_tmp111_ = _tmp110_;
				_tmp112_ = end;
				_tmp113_ = soy_atoms_position_get_z (_tmp112_);
				_tmp114_ = _tmp113_;
				dGeomSetPosition (_tmp105_, (dReal) _tmp108_, (dReal) _tmp111_, (dReal) _tmp114_);
				_tmp115_ = middle;
				_tmp116_ = start;
				_tmp117_ = soy_atoms_position_get_x (_tmp116_);
				_tmp118_ = _tmp117_;
				_tmp119_ = end;
				_tmp120_ = soy_atoms_position_get_x (_tmp119_);
				_tmp121_ = _tmp120_;
				_tmp122_ = start;
				_tmp123_ = soy_atoms_position_get_x (_tmp122_);
				_tmp124_ = _tmp123_;
				_tmp125_ = start;
				_tmp126_ = soy_atoms_position_get_y (_tmp125_);
				_tmp127_ = _tmp126_;
				_tmp128_ = end;
				_tmp129_ = soy_atoms_position_get_y (_tmp128_);
				_tmp130_ = _tmp129_;
				_tmp131_ = start;
				_tmp132_ = soy_atoms_position_get_y (_tmp131_);
				_tmp133_ = _tmp132_;
				_tmp134_ = start;
				_tmp135_ = soy_atoms_position_get_z (_tmp134_);
				_tmp136_ = _tmp135_;
				_tmp137_ = end;
				_tmp138_ = soy_atoms_position_get_z (_tmp137_);
				_tmp139_ = _tmp138_;
				_tmp140_ = start;
				_tmp141_ = soy_atoms_position_get_z (_tmp140_);
				_tmp142_ = _tmp141_;
				dGeomSetPosition (_tmp115_, (dReal) (_tmp118_ + ((_tmp121_ - _tmp124_) / 2.0f)), (dReal) (_tmp127_ + ((_tmp130_ - _tmp133_) / 2.0f)), (dReal) (_tmp136_ + ((_tmp139_ - _tmp142_) / 2.0f)));
				_tmp143_ = dmatrix3_new ();
				rot = _tmp143_;
				_tmp144_ = rot;
				_tmp145_ = axis_x;
				_tmp146_ = axis_y;
				_tmp147_ = axis_z;
				_tmp148_ = angle;
				dRFromAxisAndAngle (_tmp144_, (dReal) _tmp145_, (dReal) _tmp146_, (dReal) _tmp147_, (dReal) _tmp148_);
				_tmp149_ = middle;
				_tmp150_ = rot;
				dGeomSetRotation (_tmp149_, _tmp150_);
				_tmp151_ = box_end;
				_tmp152_ = collide_bits;
				dGeomSetCollideBits (_tmp151_, _tmp152_);
				_tmp153_ = middle;
				_tmp154_ = collide_bits;
				dGeomSetCollideBits (_tmp153_, _tmp154_);
				_tmp155_ = box_end;
				_tmp156_ = category_bits;
				dGeomSetCategoryBits (_tmp155_, _tmp156_);
				_tmp157_ = middle;
				_tmp158_ = category_bits;
				dGeomSetCategoryBits (_tmp157_, _tmp158_);
				_tmp159_ = box_end;
				_tmp160_ = ret;
				_tmp160__length1 = ret_length1;
				_tmp161_ = i;
				dGeomSetData (_tmp159_, (void*) (&_tmp160_[_tmp161_]));
				_tmp162_ = middle;
				_tmp163_ = ret;
				_tmp163__length1 = ret_length1;
				_tmp164_ = i;
				dGeomSetData (_tmp162_, (void*) (&_tmp163_[_tmp164_]));
				_tmp165_ = geoms;
				_tmp165__length1 = geoms_length1;
				_tmp166_ = i;
				_tmp167_ = middle;
				_tmp165_[2 * _tmp166_] = _tmp167_;
				_tmp168_ = _tmp165_[2 * _tmp166_];
				_tmp169_ = geoms;
				_tmp169__length1 = geoms_length1;
				_tmp170_ = i;
				_tmp171_ = box_end;
				_tmp169_[(2 * _tmp170_) + 1] = _tmp171_;
				_tmp172_ = _tmp169_[(2 * _tmp170_) + 1];
				_dmatrix3_free0 (rot);
				_g_object_unref0 (end);
			}
		}
	}
	_tmp173_ = self->space;
	dSpaceCollide (_tmp173_, self, __soy_scenes_scene_check_collisions_NearCallback_dnear_callback);
	_tmp174_ = box_start;
	dGeomDestroy (_tmp174_);
	_tmp175_ = geoms;
	_tmp175__length1 = geoms_length1;
	{
		struct dxGeom** i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp175_;
		i_collection_length1 = _tmp175__length1;
		for (i_it = 0; i_it < _tmp175__length1; i_it = i_it + 1) {
			struct dxGeom* i = NULL;
			i = i_collection[i_it];
			{
				struct dxGeom* _tmp176_;
				_tmp176_ = i;
				dGeomDestroy (_tmp176_);
			}
		}
	}
	g_rw_lock_writer_unlock (&self->stepLock);
	_tmp177_ = start_bool;
	if (_tmp177_) {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp178_;
				_tmp178_ = TRUE;
				while (TRUE) {
					gboolean _tmp179_;
					soyatomsPosition** _tmp181_;
					gint _tmp181__length1;
					gboolean* _tmp182_;
					gint _tmp182__length1;
					gint _tmp183_;
					gboolean _tmp184_;
					_tmp179_ = _tmp178_;
					if (!_tmp179_) {
						gint _tmp180_;
						_tmp180_ = i;
						i = _tmp180_ + 1;
					}
					_tmp178_ = FALSE;
					_tmp181_ = ends;
					_tmp181__length1 = ends_length1;
					if (!(i <= (_tmp181__length1 - 1))) {
						break;
					}
					_tmp182_ = ret;
					_tmp182__length1 = ret_length1;
					_tmp183_ = i;
					_tmp182_[_tmp183_] = TRUE;
					_tmp184_ = _tmp182_[_tmp183_];
				}
			}
		}
	}
	_tmp185_ = ret;
	_tmp185__length1 = ret_length1;
	if (result_length1) {
		*result_length1 = _tmp185__length1;
	}
	result = _tmp185_;
	geoms = (g_free (geoms), NULL);
	return result;
}


static void _soy_scenes_scene_ambient_set (soyscenesScene* self, soyatomsColor* color) {
	soyatomsColor* _tmp0_;
	gint _tmp1_ = 0;
	gfloat* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = color;
	_tmp2_ = soy_atoms_color_get4f (_tmp0_, &_tmp1_);
	self->priv->_ambient = (g_free (self->priv->_ambient), NULL);
	self->priv->_ambient = _tmp2_;
	self->priv->_ambient_length1 = _tmp1_;
	self->priv->__ambient_size_ = self->priv->_ambient_length1;
}


static void _soy_scenes_scene_ambient_weak (soyscenesScene* self, GObject* ambient) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (ambient != NULL);
	self->priv->_ambient_obj = NULL;
}


static void _soy_scenes_scene_fog_set (soyscenesScene* self, soyatomsColor* color) {
	soyatomsColor* _tmp0_;
	gint _tmp1_ = 0;
	gfloat* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = color;
	_tmp2_ = soy_atoms_color_get4f (_tmp0_, &_tmp1_);
	self->priv->_fog = (g_free (self->priv->_fog), NULL);
	self->priv->_fog = _tmp2_;
	self->priv->_fog_length1 = _tmp1_;
	self->priv->__fog_size_ = self->priv->_fog_length1;
}


static void _soy_scenes_scene_fog_weak (soyscenesScene* self, GObject* ambient) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (ambient != NULL);
	self->priv->_fog_obj = NULL;
}


static void _soy_scenes_scene_gravity_set (soyscenesScene* self, soyatomsVector* gravity) {
	struct dxWorld* _tmp0_;
	soyatomsVector* _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	soyatomsVector* _tmp4_;
	gfloat _tmp5_;
	gfloat _tmp6_;
	soyatomsVector* _tmp7_;
	gfloat _tmp8_;
	gfloat _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (gravity != NULL);
	g_rw_lock_writer_lock (&self->stepLock);
	_tmp0_ = self->world;
	_tmp1_ = gravity;
	_tmp2_ = soy_atoms_vector_get_x (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gravity;
	_tmp5_ = soy_atoms_vector_get_y (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = gravity;
	_tmp8_ = soy_atoms_vector_get_z (_tmp7_);
	_tmp9_ = _tmp8_;
	dWorldSetGravity (_tmp0_, (dReal) _tmp3_, (dReal) _tmp6_, (dReal) _tmp9_);
	g_rw_lock_writer_unlock (&self->stepLock);
}


static void _soy_scenes_scene_gravity_weak (soyscenesScene* self, GObject* gravity) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (gravity != NULL);
	self->priv->_gravity_obj = NULL;
}


guint64 soy_scenes_scene_get_time (soyscenesScene* self) {
	guint64 result;
	guint64 _tmp0_;
	g_return_val_if_fail (self != NULL, 0ULL);
	_tmp0_ = self->priv->_time;
	result = _tmp0_;
	return result;
}


static void __soy_scenes_scene_ambient_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self) {
	_soy_scenes_scene_ambient_set (self, color);
}


static void __soy_scenes_scene_ambient_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_scenes_scene_ambient_weak (self, object);
}


soyatomsColor* soy_scenes_scene_get_ambient (soyscenesScene* self) {
	soyatomsColor* result;
	soyatomsColor* _tmp0_;
	soyatomsColor* _tmp1_;
	soyatomsColor* value;
	soyatomsColor* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_ambient_obj;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	value = _tmp1_;
	_tmp2_ = value;
	if (_tmp2_ == NULL) {
		GLfloat* _tmp3_;
		gint _tmp3__length1;
		soyatomsColor* _tmp4_;
		soyatomsColor* _tmp5_;
		soyatomsColor* _tmp6_;
		soyatomsColor* _tmp7_;
		_tmp3_ = self->priv->_ambient;
		_tmp3__length1 = self->priv->_ambient_length1;
		_tmp4_ = soy_atoms_color_new_new4f (_tmp3_, _tmp3__length1);
		_g_object_unref0 (value);
		value = _tmp4_;
		_tmp5_ = value;
		g_signal_connect_object (_tmp5_, "on-set", (GCallback) __soy_scenes_scene_ambient_set_soy_atoms_color_on_set, self, 0);
		_tmp6_ = value;
		g_object_weak_ref ((GObject*) _tmp6_, __soy_scenes_scene_ambient_weak_gweak_notify, self);
		_tmp7_ = value;
		self->priv->_ambient_obj = _tmp7_;
	}
	result = value;
	return result;
}


void soy_scenes_scene_set_ambient (soyscenesScene* self, soyatomsColor* value) {
	soyatomsColor* _tmp0_;
	soyatomsColor* _tmp1_;
	soyatomsColor* _tmp5_;
	soyatomsColor* _tmp6_;
	soyatomsColor* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_soy_scenes_scene_ambient_set (self, _tmp0_);
	_tmp1_ = self->priv->_ambient_obj;
	if (_tmp1_ != NULL) {
		soyatomsColor* _tmp2_;
		guint _tmp3_ = 0U;
		soyatomsColor* _tmp4_;
		_tmp2_ = self->priv->_ambient_obj;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_COLOR, &_tmp3_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) __soy_scenes_scene_ambient_set_soy_atoms_color_on_set, self);
		_tmp4_ = self->priv->_ambient_obj;
		g_object_weak_unref ((GObject*) _tmp4_, __soy_scenes_scene_ambient_weak_gweak_notify, self);
	}
	_tmp5_ = value;
	self->priv->_ambient_obj = _tmp5_;
	_tmp6_ = value;
	g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_scenes_scene_ambient_set_soy_atoms_color_on_set, self, 0);
	_tmp7_ = value;
	g_object_weak_ref ((GObject*) _tmp7_, __soy_scenes_scene_ambient_weak_gweak_notify, self);
	g_object_notify ((GObject *) self, "ambient");
}


static void __soy_scenes_scene_fog_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self) {
	_soy_scenes_scene_fog_set (self, color);
}


static void __soy_scenes_scene_fog_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_scenes_scene_fog_weak (self, object);
}


soyatomsColor* soy_scenes_scene_get_fog (soyscenesScene* self) {
	soyatomsColor* result;
	soyatomsColor* _tmp0_;
	soyatomsColor* _tmp1_;
	soyatomsColor* value;
	soyatomsColor* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_fog_obj;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	value = _tmp1_;
	_tmp2_ = value;
	if (_tmp2_ == NULL) {
		GLfloat* _tmp3_;
		gint _tmp3__length1;
		soyatomsColor* _tmp4_;
		soyatomsColor* _tmp5_;
		soyatomsColor* _tmp6_;
		soyatomsColor* _tmp7_;
		_tmp3_ = self->priv->_fog;
		_tmp3__length1 = self->priv->_fog_length1;
		_tmp4_ = soy_atoms_color_new_new4f (_tmp3_, _tmp3__length1);
		_g_object_unref0 (value);
		value = _tmp4_;
		_tmp5_ = value;
		g_signal_connect_object (_tmp5_, "on-set", (GCallback) __soy_scenes_scene_fog_set_soy_atoms_color_on_set, self, 0);
		_tmp6_ = value;
		g_object_weak_ref ((GObject*) _tmp6_, __soy_scenes_scene_fog_weak_gweak_notify, self);
		_tmp7_ = value;
		self->priv->_fog_obj = _tmp7_;
	}
	result = value;
	return result;
}


void soy_scenes_scene_set_fog (soyscenesScene* self, soyatomsColor* value) {
	soyatomsColor* _tmp0_;
	soyatomsColor* _tmp1_;
	soyatomsColor* _tmp5_;
	soyatomsColor* _tmp6_;
	soyatomsColor* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_soy_scenes_scene_fog_set (self, _tmp0_);
	_tmp1_ = self->priv->_fog_obj;
	if (_tmp1_ != NULL) {
		soyatomsColor* _tmp2_;
		guint _tmp3_ = 0U;
		soyatomsColor* _tmp4_;
		_tmp2_ = self->priv->_fog_obj;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_COLOR, &_tmp3_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) __soy_scenes_scene_fog_set_soy_atoms_color_on_set, self);
		_tmp4_ = self->priv->_fog_obj;
		g_object_weak_unref ((GObject*) _tmp4_, __soy_scenes_scene_fog_weak_gweak_notify, self);
	}
	_tmp5_ = value;
	self->priv->_fog_obj = _tmp5_;
	_tmp6_ = value;
	g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_scenes_scene_fog_set_soy_atoms_color_on_set, self, 0);
	_tmp7_ = value;
	g_object_weak_ref ((GObject*) _tmp7_, __soy_scenes_scene_fog_weak_gweak_notify, self);
	g_object_notify ((GObject *) self, "fog");
}


static void __soy_scenes_scene_gravity_set_soy_atoms_vector_on_set (soyatomsVector* _sender, soyatomsVector* vector, gpointer self) {
	_soy_scenes_scene_gravity_set (self, vector);
}


static void __soy_scenes_scene_gravity_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_scenes_scene_gravity_weak (self, object);
}


soyatomsVector* soy_scenes_scene_get_gravity (soyscenesScene* self) {
	soyatomsVector* result;
	dxVector3* _tmp0_;
	dxVector3* gravity;
	struct dxWorld* _tmp1_;
	dxVector3* _tmp2_;
	soyatomsVector* _tmp3_;
	soyatomsVector* _tmp4_;
	soyatomsVector* value;
	soyatomsVector* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = dvector3_new ();
	gravity = _tmp0_;
	_tmp1_ = self->world;
	_tmp2_ = gravity;
	dWorldGetGravity (_tmp1_, _tmp2_);
	_tmp3_ = self->priv->_gravity_obj;
	_tmp4_ = _g_object_ref0 (_tmp3_);
	value = _tmp4_;
	_tmp5_ = value;
	if (_tmp5_ == NULL) {
		dxVector3* _tmp6_;
		dReal _tmp7_;
		dxVector3* _tmp8_;
		dReal _tmp9_;
		dxVector3* _tmp10_;
		dReal _tmp11_;
		soyatomsVector* _tmp12_;
		soyatomsVector* _tmp13_;
		soyatomsVector* _tmp14_;
		soyatomsVector* _tmp15_;
		_tmp6_ = gravity;
		_tmp7_ = _tmp6_->x;
		_tmp8_ = gravity;
		_tmp9_ = _tmp8_->y;
		_tmp10_ = gravity;
		_tmp11_ = _tmp10_->z;
		_tmp12_ = soy_atoms_vector_new ((gfloat) _tmp7_, (gfloat) _tmp9_, (gfloat) _tmp11_);
		_g_object_unref0 (value);
		value = _tmp12_;
		_tmp13_ = value;
		g_signal_connect_object (_tmp13_, "on-set", (GCallback) __soy_scenes_scene_gravity_set_soy_atoms_vector_on_set, self, 0);
		_tmp14_ = value;
		g_object_weak_ref ((GObject*) _tmp14_, __soy_scenes_scene_gravity_weak_gweak_notify, self);
		_tmp15_ = value;
		self->priv->_gravity_obj = _tmp15_;
	}
	result = value;
	_dvector3_free0 (gravity);
	return result;
}


void soy_scenes_scene_set_gravity (soyscenesScene* self, soyatomsVector* value) {
	soyatomsVector* _tmp0_;
	soyatomsVector* _tmp1_;
	soyatomsVector* _tmp5_;
	soyatomsVector* _tmp6_;
	soyatomsVector* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_soy_scenes_scene_gravity_set (self, _tmp0_);
	_tmp1_ = self->priv->_gravity_obj;
	if (_tmp1_ != NULL) {
		soyatomsVector* _tmp2_;
		guint _tmp3_ = 0U;
		soyatomsVector* _tmp4_;
		_tmp2_ = self->priv->_gravity_obj;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_VECTOR, &_tmp3_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) __soy_scenes_scene_gravity_set_soy_atoms_vector_on_set, self);
		_tmp4_ = self->priv->_gravity_obj;
		g_object_weak_unref ((GObject*) _tmp4_, __soy_scenes_scene_gravity_weak_gweak_notify, self);
	}
	_tmp5_ = value;
	self->priv->_gravity_obj = _tmp5_;
	_tmp6_ = value;
	g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_scenes_scene_gravity_set_soy_atoms_vector_on_set, self, 0);
	_tmp7_ = value;
	g_object_weak_ref ((GObject*) _tmp7_, __soy_scenes_scene_gravity_weak_gweak_notify, self);
	g_object_notify ((GObject *) self, "gravity");
}


gfloat soy_scenes_scene_get_stepsize (soyscenesScene* self) {
	gfloat result;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->priv->_stepsize;
	result = _tmp0_;
	return result;
}


void soy_scenes_scene_set_stepsize (soyscenesScene* self, gfloat value) {
	gfloat _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_stepsize = _tmp0_;
	g_object_notify ((GObject *) self, "stepsize");
}


static void soy_scenes_scene_class_init (soyscenesSceneClass * klass) {
	soyscenes_PhysicsThread* _tmp0_;
	soy_scenes_scene_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (soyscenesScenePrivate));
	SOY_SCENES_SCENE_CLASS (klass)->do_in_step = soy_scenes_scene_real_do_in_step;
	SOY_SCENES_SCENE_CLASS (klass)->render = soy_scenes_scene_real_render;
	G_OBJECT_CLASS (klass)->get_property = _vala_soy_scenes_scene_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_soy_scenes_scene_set_property;
	G_OBJECT_CLASS (klass)->finalize = soy_scenes_scene_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_SCENES_SCENE_TIME, g_param_spec_uint64 ("time", "time", "time", 0, G_MAXUINT64, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_SCENES_SCENE_AMBIENT, g_param_spec_object ("ambient", "ambient", "ambient", SOY_ATOMS_TYPE_COLOR, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_SCENES_SCENE_FOG, g_param_spec_object ("fog", "fog", "fog", SOY_ATOMS_TYPE_COLOR, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_SCENES_SCENE_GRAVITY, g_param_spec_object ("gravity", "gravity", "gravity", SOY_ATOMS_TYPE_VECTOR, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_SCENES_SCENE_STEPSIZE, g_param_spec_float ("stepsize", "stepsize", "stepsize", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	_tmp0_ = soy_scenes__physicsthread_new ();
	_g_object_unref0 (soy_scenes__thread);
	soy_scenes__thread = _tmp0_;
}


static void soy_scenes_scene_instance_init (soyscenesScene * self) {
	self->priv = SOY_SCENES_SCENE_GET_PRIVATE (self);
}


static void soy_scenes_scene_finalize (GObject* obj) {
	soyscenesScene * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_SCENES_TYPE_SCENE, soyscenesScene);
	_dWorldDestroy0 (self->world);
	_dSpaceDestroy0 (self->space);
	_dJointGroupDestroy0 (self->priv->_contactGroup);
	_vala_clear_GRWLock (&self->stepLock);
	_g_object_unref0 (self->lights);
	_g_object_unref0 (self->bodies);
	_g_object_unref0 (self->joints);
	_g_object_unref0 (self->Controllers);
	_g_object_unref0 (self->fields);
	_g_object_unref0 (self->priv->_callFields);
	_g_object_unref0 (self->priv->_giveFields);
	self->priv->_ambient = (g_free (self->priv->_ambient), NULL);
	self->priv->_fog = (g_free (self->priv->_fog), NULL);
	G_OBJECT_CLASS (soy_scenes_scene_parent_class)->finalize (obj);
}


GType soy_scenes_scene_get_type (void) {
	static volatile gsize soy_scenes_scene_type_id__volatile = 0;
	if (g_once_init_enter (&soy_scenes_scene_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (soyscenesSceneClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) soy_scenes_scene_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (soyscenesScene), 0, (GInstanceInitFunc) soy_scenes_scene_instance_init, NULL };
		GType soy_scenes_scene_type_id;
		soy_scenes_scene_type_id = g_type_register_static (G_TYPE_OBJECT, "soyscenesScene", &g_define_type_info, 0);
		g_once_init_leave (&soy_scenes_scene_type_id__volatile, soy_scenes_scene_type_id);
	}
	return soy_scenes_scene_type_id__volatile;
}


static void _vala_soy_scenes_scene_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	soyscenesScene * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_SCENES_TYPE_SCENE, soyscenesScene);
	switch (property_id) {
		case SOY_SCENES_SCENE_TIME:
		g_value_set_uint64 (value, soy_scenes_scene_get_time (self));
		break;
		case SOY_SCENES_SCENE_AMBIENT:
		g_value_take_object (value, soy_scenes_scene_get_ambient (self));
		break;
		case SOY_SCENES_SCENE_FOG:
		g_value_take_object (value, soy_scenes_scene_get_fog (self));
		break;
		case SOY_SCENES_SCENE_GRAVITY:
		g_value_take_object (value, soy_scenes_scene_get_gravity (self));
		break;
		case SOY_SCENES_SCENE_STEPSIZE:
		g_value_set_float (value, soy_scenes_scene_get_stepsize (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_soy_scenes_scene_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	soyscenesScene * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_SCENES_TYPE_SCENE, soyscenesScene);
	switch (property_id) {
		case SOY_SCENES_SCENE_AMBIENT:
		soy_scenes_scene_set_ambient (self, g_value_get_object (value));
		break;
		case SOY_SCENES_SCENE_FOG:
		soy_scenes_scene_set_fog (self, g_value_get_object (value));
		break;
		case SOY_SCENES_SCENE_GRAVITY:
		soy_scenes_scene_set_gravity (self, g_value_get_object (value));
		break;
		case SOY_SCENES_SCENE_STEPSIZE:
		soy_scenes_scene_set_stepsize (self, g_value_get_float (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static void _vala_clear_GMutex (GMutex * mutex) {
	GMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GMutex))) {
		g_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GMutex));
	}
}


static void _vala_clear_GRecMutex (GRecMutex * mutex) {
	GRecMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRecMutex))) {
		g_rec_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GRecMutex));
	}
}


static void _vala_clear_GRWLock (GRWLock * mutex) {
	GRWLock zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRWLock))) {
		g_rw_lock_clear (mutex);
		memset (mutex, 0, sizeof (GRWLock));
	}
}


static void _vala_clear_GCond (GCond * mutex) {
	GCond zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GCond))) {
		g_cond_clear (mutex);
		memset (mutex, 0, sizeof (GCond));
	}
}



