/* Texture.c generated by valac 0.18.1, the Vala compiler
 * generated from Texture.gs, do not modify */

/*
 *  libsoy - soy.textures.Texture
 *  Copyright (C) 2006,2007,2008,2009,2010,2011,2012 Copyleft Games Group
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program; if not, see http://www.gnu.org/licenses
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <GLES/gl.h>
#include <GLES/glext.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <librsvg/rsvg.h>
#include <stdio.h>


#define SOY_TEXTURES_TYPE_TEXTURE (soy_textures_texture_get_type ())
#define SOY_TEXTURES_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture))
#define SOY_TEXTURES_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTextureClass))
#define SOY_TEXTURES_IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_TEXTURES_TYPE_TEXTURE))
#define SOY_TEXTURES_IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_TEXTURES_TYPE_TEXTURE))
#define SOY_TEXTURES_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTextureClass))

typedef struct _soytexturesTexture soytexturesTexture;
typedef struct _soytexturesTextureClass soytexturesTextureClass;
typedef struct _soytexturesTexturePrivate soytexturesTexturePrivate;

#define SOY_ATOMS_TYPE_COLOR (soy_atoms_color_get_type ())
#define SOY_ATOMS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColor))
#define SOY_ATOMS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))
#define SOY_ATOMS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))

typedef struct _soyatomsColor soyatomsColor;
typedef struct _soyatomsColorClass soyatomsColorClass;

#define SOY_ATOMS_TYPE_SIZE (soy_atoms_size_get_type ())
#define SOY_ATOMS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSize))
#define SOY_ATOMS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))
#define SOY_ATOMS_IS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_IS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_SIZE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))

typedef struct _soyatomsSize soyatomsSize;
typedef struct _soyatomsSizeClass soyatomsSizeClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _soytexturesTexture {
	GObject parent_instance;
	soytexturesTexturePrivate * priv;
	guchar* texels;
};

struct _soytexturesTextureClass {
	GObjectClass parent_class;
	void (*enable) (soytexturesTexture* self);
	void (*disable) (soytexturesTexture* self);
};

struct _soytexturesTexturePrivate {
	GLuint _textureID;
	GeeHashMap* _texel_objs;
	gint _isAnimated;
	GLfloat _scaleX;
	GLfloat _scaleY;
	gboolean _updated;
	GMutex _mutex;
	GLfloat* _animate;
	gint _animate_length1;
	gint __animate_size_;
	gfloat _aspect;
	gint _chans;
	GLsizei _width;
	GLsizei _height;
	soyatomsSize* _size_obj;
	gboolean _smooth;
};


static gpointer soy_textures_texture_parent_class = NULL;
static GLenum* soy_textures_texture__formats;
static gint soy_textures_texture__formats_length1;
static GLenum* soy_textures_texture__formats = NULL;
static gint soy_textures_texture__formats_length1 = 0;
static gint _soy_textures_texture__formats_size_ = 0;

GType soy_textures_texture_get_type (void) G_GNUC_CONST;
GType soy_atoms_color_get_type (void) G_GNUC_CONST;
GType soy_atoms_size_get_type (void) G_GNUC_CONST;
#define SOY_TEXTURES_TEXTURE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexturePrivate))
enum  {
	SOY_TEXTURES_TEXTURE_DUMMY_PROPERTY,
	SOY_TEXTURES_TEXTURE_ASPECT,
	SOY_TEXTURES_TEXTURE_CHANNELS,
	SOY_TEXTURES_TEXTURE_SIZE,
	SOY_TEXTURES_TEXTURE_SMOOTH
};
soytexturesTexture* soy_textures_texture_new (void);
soytexturesTexture* soy_textures_texture_construct (GType object_type);
soytexturesTexture* soy_textures_texture_new_from_png (const gchar* filename);
soytexturesTexture* soy_textures_texture_construct_from_png (GType object_type, const gchar* filename);
static void _soy_textures_texture_copySurface (soytexturesTexture* self, cairo_surface_t* surface);
soytexturesTexture* soy_textures_texture_new_from_svg (const gchar* filename);
soytexturesTexture* soy_textures_texture_construct_from_svg (GType object_type, const gchar* filename);
static void _soy_textures_texture_size_set (soytexturesTexture* self, soyatomsSize* size);
void soy_textures_texture_resize (soytexturesTexture* self, gint c, gint x, gint y);
gfloat soy_atoms_size_get_width (soyatomsSize* self);
gfloat soy_atoms_size_get_height (soyatomsSize* self);
static void _soy_textures_texture_size_weak (soytexturesTexture* self, GObject* size);
soyatomsColor* soy_textures_texture_get (soytexturesTexture* self, gint index);
soyatomsColor* soy_atoms_color_new (guchar red, guchar green, guchar blue, guchar alpha);
soyatomsColor* soy_atoms_color_construct (GType object_type, guchar red, guchar green, guchar blue, guchar alpha);
static void _soy_textures_texture_texel_set (soytexturesTexture* self, soyatomsColor* color);
static void __soy_textures_texture_texel_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self);
static void _soy_textures_texture_texel_weak (soytexturesTexture* self, GObject* color);
static void __soy_textures_texture_texel_weak_gweak_notify (gpointer self, GObject* object);
void soy_textures_texture_set (soytexturesTexture* self, gint index, GObject* value);
guchar soy_atoms_color_get_luma (soyatomsColor* self);
guchar soy_atoms_color_get_alpha (soyatomsColor* self);
guchar soy_atoms_color_get_red (soyatomsColor* self);
guchar soy_atoms_color_get_green (soyatomsColor* self);
guchar soy_atoms_color_get_blue (soyatomsColor* self);
gint soy_textures_texture_squareup (gint _v);
void soy_textures_texture_update (soytexturesTexture* self, GLenum target);
void soy_textures_texture_enable (soytexturesTexture* self);
static void soy_textures_texture_real_enable (soytexturesTexture* self);
void soy_textures_texture_disable (soytexturesTexture* self);
static void soy_textures_texture_real_disable (soytexturesTexture* self);
void soy_textures_texture_load (soytexturesTexture* self, void* _vdata, gint _size);
static guchar* _vala_array_dup4 (guchar* self, int length);
GLfloat* soy_textures_texture_get_animate (soytexturesTexture* self, int* result_length1);
gfloat soy_textures_texture_get_aspect (soytexturesTexture* self);
gint soy_textures_texture_get_channels (soytexturesTexture* self);
void soy_textures_texture_set_channels (soytexturesTexture* self, gint value);
soyatomsSize* soy_textures_texture_get_size (soytexturesTexture* self);
soyatomsSize* soy_atoms_size_new (gfloat width, gfloat height, gfloat depth);
soyatomsSize* soy_atoms_size_construct (GType object_type, gfloat width, gfloat height, gfloat depth);
static void __soy_textures_texture_size_set_soy_atoms_size_on_set (soyatomsSize* _sender, soyatomsSize* size, gpointer self);
static void __soy_textures_texture_size_weak_gweak_notify (gpointer self, GObject* object);
void soy_textures_texture_set_size (soytexturesTexture* self, soyatomsSize* value);
gboolean soy_textures_texture_get_smooth (soytexturesTexture* self);
void soy_textures_texture_set_smooth (soytexturesTexture* self, gboolean value);
static GObject * soy_textures_texture_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void soy_textures_texture_finalize (GObject* obj);
static void _vala_soy_textures_texture_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_soy_textures_texture_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_clear_GMutex (GMutex * mutex);
static void _vala_clear_GRecMutex (GRecMutex * mutex);
static void _vala_clear_GRWLock (GRWLock * mutex);
static void _vala_clear_GCond (GCond * mutex);


soytexturesTexture* soy_textures_texture_construct (GType object_type) {
	soytexturesTexture * self = NULL;
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	self->priv->_chans = 3;
	return self;
}


soytexturesTexture* soy_textures_texture_new (void) {
	return soy_textures_texture_construct (SOY_TEXTURES_TYPE_TEXTURE);
}


soytexturesTexture* soy_textures_texture_construct_from_png (GType object_type, const gchar* filename) {
	soytexturesTexture * self = NULL;
	cairo_surface_t* surface = NULL;
	const gchar* _tmp0_;
	cairo_surface_t* _tmp1_;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	_tmp0_ = filename;
	_tmp1_ = cairo_image_surface_create_from_png (_tmp0_);
	_cairo_surface_destroy0 (surface);
	surface = _tmp1_;
	_soy_textures_texture_copySurface (self, surface);
	_cairo_surface_destroy0 (surface);
	return self;
}


soytexturesTexture* soy_textures_texture_new_from_png (const gchar* filename) {
	return soy_textures_texture_construct_from_png (SOY_TEXTURES_TYPE_TEXTURE, filename);
}


soytexturesTexture* soy_textures_texture_construct_from_svg (GType object_type, const gchar* filename) {
	soytexturesTexture * self = NULL;
	cairo_t* context = NULL;
	RsvgHandle* handle = NULL;
	cairo_surface_t* surface = NULL;
	cairo_surface_t* _tmp17_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	{
		const gchar* _tmp0_;
		RsvgHandle* _tmp1_;
		RsvgHandle* _tmp2_;
		RsvgHandle* _tmp3_;
		gint _tmp4_ = 0;
		gint _tmp5_;
		RsvgHandle* _tmp6_;
		gint _tmp7_ = 0;
		gint _tmp8_;
		cairo_surface_t* _tmp9_;
		cairo_surface_t* _tmp10_;
		cairo_t* _tmp11_;
		RsvgHandle* _tmp12_;
		cairo_t* _tmp13_;
		_tmp0_ = filename;
		_tmp1_ = rsvg_handle_new_from_file (_tmp0_, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch10_g_error;
		}
		_g_object_unref0 (handle);
		handle = _tmp2_;
		_tmp3_ = handle;
		g_object_get (_tmp3_, "width", &_tmp4_, NULL);
		_tmp5_ = _tmp4_;
		_tmp6_ = handle;
		g_object_get (_tmp6_, "height", &_tmp7_, NULL);
		_tmp8_ = _tmp7_;
		_tmp9_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp5_, _tmp8_);
		_cairo_surface_destroy0 (surface);
		surface = _tmp9_;
		_tmp10_ = surface;
		_tmp11_ = cairo_create (_tmp10_);
		_cairo_destroy0 (context);
		context = _tmp11_;
		_tmp12_ = handle;
		_tmp13_ = context;
		rsvg_handle_render_cairo (_tmp12_, _tmp13_);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError* g = NULL;
		FILE* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		g = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = stdout;
		_tmp15_ = g;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "Error: %s\n", _tmp16_);
		_g_error_free0 (g);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		return self;
	}
	__finally10:
	if (_inner_error_ != NULL) {
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp17_ = surface;
	_soy_textures_texture_copySurface (self, _tmp17_);
	_cairo_surface_destroy0 (surface);
	_g_object_unref0 (handle);
	_cairo_destroy0 (context);
	return self;
}


soytexturesTexture* soy_textures_texture_new_from_svg (const gchar* filename) {
	return soy_textures_texture_construct_from_svg (SOY_TEXTURES_TYPE_TEXTURE, filename);
}


static void _soy_textures_texture_size_set (soytexturesTexture* self, soyatomsSize* size) {
	gint _tmp0_;
	soyatomsSize* _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	glong _tmp4_ = 0L;
	soyatomsSize* _tmp5_;
	gfloat _tmp6_;
	gfloat _tmp7_;
	glong _tmp8_ = 0L;
	g_return_if_fail (self != NULL);
	g_return_if_fail (size != NULL);
	_tmp0_ = self->priv->_chans;
	_tmp1_ = size;
	_tmp2_ = soy_atoms_size_get_width (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = lround ((gdouble) _tmp3_);
	_tmp5_ = size;
	_tmp6_ = soy_atoms_size_get_height (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = lround ((gdouble) _tmp7_);
	soy_textures_texture_resize (self, _tmp0_, (gint) ((GLsizei) _tmp4_), (gint) ((GLsizei) _tmp8_));
}


static void _soy_textures_texture_size_weak (soytexturesTexture* self, GObject* size) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (size != NULL);
	self->priv->_size_obj = NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __soy_textures_texture_texel_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self) {
	_soy_textures_texture_texel_set (self, color);
}


static void __soy_textures_texture_texel_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_textures_texture_texel_weak (self, object);
}


soyatomsColor* soy_textures_texture_get (soytexturesTexture* self, gint index) {
	soyatomsColor* result = NULL;
	soyatomsColor* ret;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp5_;
	GeeHashMap* _tmp6_;
	gint _tmp7_;
	gboolean _tmp8_ = FALSE;
	soyatomsColor* _tmp64_;
	soyatomsColor* _tmp65_;
	GeeHashMap* _tmp66_;
	gint _tmp67_;
	soyatomsColor* _tmp68_;
	soyatomsColor* _tmp69_;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	_tmp1_ = index;
	if (_tmp1_ < 0) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		GLsizei _tmp3_;
		GLsizei _tmp4_;
		_tmp2_ = index;
		_tmp3_ = self->priv->_width;
		_tmp4_ = self->priv->_height;
		_tmp0_ = _tmp2_ >= ((gint) (_tmp3_ * _tmp4_));
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		result = NULL;
		_g_object_unref0 (ret);
		return result;
	}
	_tmp6_ = self->priv->_texel_objs;
	_tmp7_ = index;
	_tmp8_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp6_, (gpointer) ((gintptr) _tmp7_));
	if (_tmp8_) {
		GeeHashMap* _tmp9_;
		gint _tmp10_;
		gpointer _tmp11_ = NULL;
		soyatomsColor* _tmp12_;
		_tmp9_ = self->priv->_texel_objs;
		_tmp10_ = index;
		_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp9_, (gpointer) ((gintptr) _tmp10_));
		_tmp12_ = _g_object_ref0 ((soyatomsColor*) _tmp11_);
		_g_object_unref0 (ret);
		ret = _tmp12_;
	} else {
		gint _tmp13_;
		_tmp13_ = self->priv->_chans;
		if (_tmp13_ == 1) {
			guchar* _tmp14_;
			gint _tmp15_;
			guchar _tmp16_;
			guchar l;
			guchar _tmp17_;
			guchar _tmp18_;
			guchar _tmp19_;
			soyatomsColor* _tmp20_;
			_tmp14_ = self->texels;
			_tmp15_ = index;
			_tmp16_ = _tmp14_[_tmp15_];
			l = _tmp16_;
			_tmp17_ = l;
			_tmp18_ = l;
			_tmp19_ = l;
			_tmp20_ = soy_atoms_color_new (_tmp17_, _tmp18_, _tmp19_, (guchar) 255);
			_g_object_unref0 (ret);
			ret = _tmp20_;
		} else {
			gint _tmp21_;
			_tmp21_ = self->priv->_chans;
			if (_tmp21_ == 2) {
				guchar* _tmp22_;
				gint _tmp23_;
				guchar _tmp24_;
				guchar l;
				guchar* _tmp25_;
				gint _tmp26_;
				guchar _tmp27_;
				guchar a;
				guchar _tmp28_;
				guchar _tmp29_;
				guchar _tmp30_;
				guchar _tmp31_;
				soyatomsColor* _tmp32_;
				_tmp22_ = self->texels;
				_tmp23_ = index;
				_tmp24_ = _tmp22_[_tmp23_ * 2];
				l = _tmp24_;
				_tmp25_ = self->texels;
				_tmp26_ = index;
				_tmp27_ = _tmp25_[(_tmp26_ * 2) + 1];
				a = _tmp27_;
				_tmp28_ = l;
				_tmp29_ = l;
				_tmp30_ = l;
				_tmp31_ = a;
				_tmp32_ = soy_atoms_color_new (_tmp28_, _tmp29_, _tmp30_, _tmp31_);
				_g_object_unref0 (ret);
				ret = _tmp32_;
			} else {
				gint _tmp33_;
				_tmp33_ = self->priv->_chans;
				if (_tmp33_ == 3) {
					guchar* _tmp34_;
					gint _tmp35_;
					guchar _tmp36_;
					guchar r;
					guchar* _tmp37_;
					gint _tmp38_;
					guchar _tmp39_;
					guchar g;
					guchar* _tmp40_;
					gint _tmp41_;
					guchar _tmp42_;
					guchar b;
					guchar _tmp43_;
					guchar _tmp44_;
					guchar _tmp45_;
					soyatomsColor* _tmp46_;
					_tmp34_ = self->texels;
					_tmp35_ = index;
					_tmp36_ = _tmp34_[_tmp35_ * 3];
					r = _tmp36_;
					_tmp37_ = self->texels;
					_tmp38_ = index;
					_tmp39_ = _tmp37_[(_tmp38_ * 3) + 1];
					g = _tmp39_;
					_tmp40_ = self->texels;
					_tmp41_ = index;
					_tmp42_ = _tmp40_[(_tmp41_ * 3) + 2];
					b = _tmp42_;
					_tmp43_ = r;
					_tmp44_ = g;
					_tmp45_ = b;
					_tmp46_ = soy_atoms_color_new (_tmp43_, _tmp44_, _tmp45_, (guchar) 255);
					_g_object_unref0 (ret);
					ret = _tmp46_;
				} else {
					guchar* _tmp47_;
					gint _tmp48_;
					guchar _tmp49_;
					guchar r;
					guchar* _tmp50_;
					gint _tmp51_;
					guchar _tmp52_;
					guchar g;
					guchar* _tmp53_;
					gint _tmp54_;
					guchar _tmp55_;
					guchar b;
					guchar* _tmp56_;
					gint _tmp57_;
					guchar _tmp58_;
					guchar a;
					guchar _tmp59_;
					guchar _tmp60_;
					guchar _tmp61_;
					guchar _tmp62_;
					soyatomsColor* _tmp63_;
					_tmp47_ = self->texels;
					_tmp48_ = index;
					_tmp49_ = _tmp47_[_tmp48_ * 4];
					r = _tmp49_;
					_tmp50_ = self->texels;
					_tmp51_ = index;
					_tmp52_ = _tmp50_[(_tmp51_ * 4) + 1];
					g = _tmp52_;
					_tmp53_ = self->texels;
					_tmp54_ = index;
					_tmp55_ = _tmp53_[(_tmp54_ * 4) + 2];
					b = _tmp55_;
					_tmp56_ = self->texels;
					_tmp57_ = index;
					_tmp58_ = _tmp56_[(_tmp57_ * 4) + 3];
					a = _tmp58_;
					_tmp59_ = r;
					_tmp60_ = g;
					_tmp61_ = b;
					_tmp62_ = a;
					_tmp63_ = soy_atoms_color_new (_tmp59_, _tmp60_, _tmp61_, _tmp62_);
					_g_object_unref0 (ret);
					ret = _tmp63_;
				}
			}
		}
	}
	_tmp64_ = ret;
	g_signal_connect_object (_tmp64_, "on-set", (GCallback) __soy_textures_texture_texel_set_soy_atoms_color_on_set, self, 0);
	_tmp65_ = ret;
	g_object_weak_ref ((GObject*) _tmp65_, __soy_textures_texture_texel_weak_gweak_notify, self);
	_tmp66_ = self->priv->_texel_objs;
	_tmp67_ = index;
	_tmp68_ = ret;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp66_, (gpointer) ((gintptr) _tmp67_), _tmp68_);
	_tmp69_ = ret;
	ret = NULL;
	result = _tmp69_;
	_g_object_unref0 (ret);
	return result;
}


void soy_textures_texture_set (soytexturesTexture* self, gint index, GObject* value) {
	soyatomsColor* color = NULL;
	GObject* _tmp0_;
	GObject* _tmp1_;
	soyatomsColor* _tmp2_;
	GeeHashMap* _tmp3_;
	gint _tmp4_;
	gboolean _tmp5_ = FALSE;
	GeeHashMap* _tmp13_;
	gint _tmp14_;
	soyatomsColor* _tmp15_;
	soyatomsColor* _tmp16_;
	soyatomsColor* _tmp17_;
	gint _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = value;
	if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, SOY_ATOMS_TYPE_COLOR)) {
		_g_object_unref0 (color);
		return;
	}
	_tmp1_ = value;
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, SOY_ATOMS_TYPE_COLOR, soyatomsColor));
	_g_object_unref0 (color);
	color = _tmp2_;
	_tmp3_ = self->priv->_texel_objs;
	_tmp4_ = index;
	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, (gpointer) ((gintptr) _tmp4_));
	if (_tmp5_) {
		GeeHashMap* _tmp6_;
		gint _tmp7_;
		gpointer _tmp8_ = NULL;
		soyatomsColor* _tmp9_;
		soyatomsColor* old;
		soyatomsColor* _tmp10_;
		guint _tmp11_ = 0U;
		soyatomsColor* _tmp12_;
		_tmp6_ = self->priv->_texel_objs;
		_tmp7_ = index;
		_tmp8_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp6_, (gpointer) ((gintptr) _tmp7_));
		_tmp9_ = _g_object_ref0 ((soyatomsColor*) _tmp8_);
		old = _tmp9_;
		_tmp10_ = old;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_COLOR, &_tmp11_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, 0, NULL, (GCallback) __soy_textures_texture_texel_set_soy_atoms_color_on_set, self);
		_tmp12_ = old;
		g_object_weak_unref ((GObject*) _tmp12_, __soy_textures_texture_texel_weak_gweak_notify, self);
		_g_object_unref0 (old);
	}
	_tmp13_ = self->priv->_texel_objs;
	_tmp14_ = index;
	_tmp15_ = color;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp13_, (gpointer) ((gintptr) _tmp14_), _tmp15_);
	_tmp16_ = color;
	g_signal_connect_object (_tmp16_, "on-set", (GCallback) __soy_textures_texture_texel_set_soy_atoms_color_on_set, self, 0);
	_tmp17_ = color;
	g_object_weak_ref ((GObject*) _tmp17_, __soy_textures_texture_texel_weak_gweak_notify, self);
	_tmp18_ = self->priv->_chans;
	if (_tmp18_ == 1) {
		guchar* _tmp19_;
		gint _tmp20_;
		soyatomsColor* _tmp21_;
		guchar _tmp22_;
		guchar _tmp23_;
		guchar _tmp24_;
		_tmp19_ = self->texels;
		_tmp20_ = index;
		_tmp21_ = color;
		_tmp22_ = soy_atoms_color_get_luma (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp19_[_tmp20_] = _tmp23_;
		_tmp24_ = _tmp19_[_tmp20_];
	} else {
		gint _tmp25_;
		_tmp25_ = self->priv->_chans;
		if (_tmp25_ == 2) {
			guchar* _tmp26_;
			gint _tmp27_;
			soyatomsColor* _tmp28_;
			guchar _tmp29_;
			guchar _tmp30_;
			guchar _tmp31_;
			guchar* _tmp32_;
			gint _tmp33_;
			soyatomsColor* _tmp34_;
			guchar _tmp35_;
			guchar _tmp36_;
			guchar _tmp37_;
			_tmp26_ = self->texels;
			_tmp27_ = index;
			_tmp28_ = color;
			_tmp29_ = soy_atoms_color_get_luma (_tmp28_);
			_tmp30_ = _tmp29_;
			_tmp26_[_tmp27_ * 2] = _tmp30_;
			_tmp31_ = _tmp26_[_tmp27_ * 2];
			_tmp32_ = self->texels;
			_tmp33_ = index;
			_tmp34_ = color;
			_tmp35_ = soy_atoms_color_get_alpha (_tmp34_);
			_tmp36_ = _tmp35_;
			_tmp32_[(_tmp33_ * 2) + 1] = _tmp36_;
			_tmp37_ = _tmp32_[(_tmp33_ * 2) + 1];
		} else {
			gint _tmp38_;
			_tmp38_ = self->priv->_chans;
			if (_tmp38_ == 3) {
				guchar* _tmp39_;
				gint _tmp40_;
				soyatomsColor* _tmp41_;
				guchar _tmp42_;
				guchar _tmp43_;
				guchar _tmp44_;
				guchar* _tmp45_;
				gint _tmp46_;
				soyatomsColor* _tmp47_;
				guchar _tmp48_;
				guchar _tmp49_;
				guchar _tmp50_;
				guchar* _tmp51_;
				gint _tmp52_;
				soyatomsColor* _tmp53_;
				guchar _tmp54_;
				guchar _tmp55_;
				guchar _tmp56_;
				_tmp39_ = self->texels;
				_tmp40_ = index;
				_tmp41_ = color;
				_tmp42_ = soy_atoms_color_get_red (_tmp41_);
				_tmp43_ = _tmp42_;
				_tmp39_[_tmp40_ * 3] = _tmp43_;
				_tmp44_ = _tmp39_[_tmp40_ * 3];
				_tmp45_ = self->texels;
				_tmp46_ = index;
				_tmp47_ = color;
				_tmp48_ = soy_atoms_color_get_green (_tmp47_);
				_tmp49_ = _tmp48_;
				_tmp45_[(_tmp46_ * 3) + 1] = _tmp49_;
				_tmp50_ = _tmp45_[(_tmp46_ * 3) + 1];
				_tmp51_ = self->texels;
				_tmp52_ = index;
				_tmp53_ = color;
				_tmp54_ = soy_atoms_color_get_blue (_tmp53_);
				_tmp55_ = _tmp54_;
				_tmp51_[(_tmp52_ * 3) + 2] = _tmp55_;
				_tmp56_ = _tmp51_[(_tmp52_ * 3) + 2];
			} else {
				guchar* _tmp57_;
				gint _tmp58_;
				soyatomsColor* _tmp59_;
				guchar _tmp60_;
				guchar _tmp61_;
				guchar _tmp62_;
				guchar* _tmp63_;
				gint _tmp64_;
				soyatomsColor* _tmp65_;
				guchar _tmp66_;
				guchar _tmp67_;
				guchar _tmp68_;
				guchar* _tmp69_;
				gint _tmp70_;
				soyatomsColor* _tmp71_;
				guchar _tmp72_;
				guchar _tmp73_;
				guchar _tmp74_;
				guchar* _tmp75_;
				gint _tmp76_;
				soyatomsColor* _tmp77_;
				guchar _tmp78_;
				guchar _tmp79_;
				guchar _tmp80_;
				_tmp57_ = self->texels;
				_tmp58_ = index;
				_tmp59_ = color;
				_tmp60_ = soy_atoms_color_get_red (_tmp59_);
				_tmp61_ = _tmp60_;
				_tmp57_[_tmp58_ * 4] = _tmp61_;
				_tmp62_ = _tmp57_[_tmp58_ * 4];
				_tmp63_ = self->texels;
				_tmp64_ = index;
				_tmp65_ = color;
				_tmp66_ = soy_atoms_color_get_green (_tmp65_);
				_tmp67_ = _tmp66_;
				_tmp63_[(_tmp64_ * 4) + 1] = _tmp67_;
				_tmp68_ = _tmp63_[(_tmp64_ * 4) + 1];
				_tmp69_ = self->texels;
				_tmp70_ = index;
				_tmp71_ = color;
				_tmp72_ = soy_atoms_color_get_blue (_tmp71_);
				_tmp73_ = _tmp72_;
				_tmp69_[(_tmp70_ * 4) + 2] = _tmp73_;
				_tmp74_ = _tmp69_[(_tmp70_ * 4) + 2];
				_tmp75_ = self->texels;
				_tmp76_ = index;
				_tmp77_ = color;
				_tmp78_ = soy_atoms_color_get_alpha (_tmp77_);
				_tmp79_ = _tmp78_;
				_tmp75_[(_tmp76_ * 4) + 3] = _tmp79_;
				_tmp80_ = _tmp75_[(_tmp76_ * 4) + 3];
			}
		}
	}
	g_mutex_lock (&self->priv->_mutex);
	self->priv->_updated = TRUE;
	g_mutex_unlock (&self->priv->_mutex);
	_g_object_unref0 (color);
}


static void _soy_textures_texture_copySurface (soytexturesTexture* self, cairo_surface_t* surface) {
	gint chans = 0;
	gint width = 0;
	gint height = 0;
	gint stride = 0;
	guchar* data = NULL;
	cairo_surface_t* _tmp0_;
	cairo_surface_t* _tmp1_;
	cairo_format_t _tmp2_ = 0;
	cairo_surface_t* _tmp3_;
	gint _tmp4_ = 0;
	cairo_surface_t* _tmp5_;
	gint _tmp6_ = 0;
	cairo_surface_t* _tmp7_;
	gint _tmp8_ = 0;
	cairo_surface_t* _tmp9_;
	guchar* _tmp10_ = NULL;
	gint _tmp11_;
	gint _tmp12_;
	gint _tmp13_ = 0;
	gint _tmp14_;
	gint _tmp15_ = 0;
	gint _tmp16_;
	gint _tmp60_;
	gint _tmp61_;
	gint _tmp62_;
	GLsizei _tmp63_;
	gint _tmp64_;
	GLsizei _tmp65_;
	gboolean _tmp66_ = FALSE;
	GLfloat _tmp67_;
	gboolean _tmp69_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (surface != NULL);
	_tmp0_ = surface;
	cairo_surface_flush (_tmp0_);
	_tmp1_ = surface;
	_tmp2_ = cairo_image_surface_get_format (_tmp1_);
	if (_tmp2_ == CAIRO_FORMAT_RGB24) {
		chans = 3;
	} else {
		chans = 4;
	}
	_tmp3_ = surface;
	_tmp4_ = cairo_image_surface_get_width (_tmp3_);
	width = _tmp4_;
	_tmp5_ = surface;
	_tmp6_ = cairo_image_surface_get_height (_tmp5_);
	height = _tmp6_;
	_tmp7_ = surface;
	_tmp8_ = cairo_image_surface_get_stride (_tmp7_);
	stride = _tmp8_;
	_tmp9_ = surface;
	_tmp10_ = cairo_image_surface_get_data (_tmp9_);
	data = (void*) _tmp10_;
	_tmp11_ = chans;
	_tmp12_ = width;
	_tmp13_ = soy_textures_texture_squareup (_tmp12_);
	_tmp14_ = height;
	_tmp15_ = soy_textures_texture_squareup (_tmp14_);
	soy_textures_texture_resize (self, _tmp11_, _tmp13_, _tmp15_);
	_tmp16_ = self->priv->_chans;
	if (_tmp16_ == 3) {
		{
			gint y;
			y = 0;
			{
				gboolean _tmp17_;
				_tmp17_ = TRUE;
				while (TRUE) {
					gboolean _tmp18_;
					gint _tmp20_;
					_tmp18_ = _tmp17_;
					if (!_tmp18_) {
						gint _tmp19_;
						_tmp19_ = y;
						y = _tmp19_ + 1;
					}
					_tmp17_ = FALSE;
					_tmp20_ = height;
					if (!(y <= (_tmp20_ - 1))) {
						break;
					}
					{
						gint x;
						x = 0;
						{
							gboolean _tmp21_;
							_tmp21_ = TRUE;
							while (TRUE) {
								gboolean _tmp22_;
								gint _tmp24_;
								gint _tmp25_;
								gint _tmp26_;
								gint _tmp27_;
								gint src;
								gint _tmp28_;
								GLsizei _tmp29_;
								gint _tmp30_;
								gint _tmp31_;
								gint dst;
								guchar* _tmp32_;
								gint _tmp33_;
								guchar* _tmp34_;
								gint _tmp35_;
								guchar _tmp36_;
								guchar* _tmp37_;
								gint _tmp38_;
								guchar* _tmp39_;
								gint _tmp40_;
								guchar _tmp41_;
								guchar* _tmp42_;
								gint _tmp43_;
								guchar* _tmp44_;
								gint _tmp45_;
								guchar _tmp46_;
								_tmp22_ = _tmp21_;
								if (!_tmp22_) {
									gint _tmp23_;
									_tmp23_ = x;
									x = _tmp23_ + 1;
								}
								_tmp21_ = FALSE;
								_tmp24_ = width;
								if (!(x <= (_tmp24_ - 1))) {
									break;
								}
								_tmp25_ = y;
								_tmp26_ = stride;
								_tmp27_ = x;
								src = (_tmp25_ * _tmp26_) + (_tmp27_ * 4);
								_tmp28_ = y;
								_tmp29_ = self->priv->_width;
								_tmp30_ = x;
								_tmp31_ = self->priv->_chans;
								dst = ((_tmp28_ * _tmp29_) + _tmp30_) * _tmp31_;
								_tmp32_ = self->texels;
								_tmp33_ = dst;
								_tmp34_ = data;
								_tmp35_ = src;
								_tmp32_[_tmp33_] = *((_tmp34_ + _tmp35_) + 2);
								_tmp36_ = _tmp32_[_tmp33_];
								_tmp37_ = self->texels;
								_tmp38_ = dst;
								_tmp39_ = data;
								_tmp40_ = src;
								_tmp37_[_tmp38_ + 1] = *((_tmp39_ + _tmp40_) + 1);
								_tmp41_ = _tmp37_[_tmp38_ + 1];
								_tmp42_ = self->texels;
								_tmp43_ = dst;
								_tmp44_ = data;
								_tmp45_ = src;
								_tmp42_[_tmp43_ + 2] = *(_tmp44_ + _tmp45_);
								_tmp46_ = _tmp42_[_tmp43_ + 2];
							}
						}
					}
				}
			}
		}
	} else {
		{
			gint y;
			y = 0;
			{
				gboolean _tmp47_;
				_tmp47_ = TRUE;
				while (TRUE) {
					gboolean _tmp48_;
					gint _tmp50_;
					guchar* _tmp51_;
					gint _tmp52_;
					GLsizei _tmp53_;
					gint _tmp54_;
					guchar* _tmp55_;
					gint _tmp56_;
					gint _tmp57_;
					gint _tmp58_;
					gint _tmp59_;
					_tmp48_ = _tmp47_;
					if (!_tmp48_) {
						gint _tmp49_;
						_tmp49_ = y;
						y = _tmp49_ + 1;
					}
					_tmp47_ = FALSE;
					_tmp50_ = height;
					if (!(y <= (_tmp50_ - 1))) {
						break;
					}
					_tmp51_ = self->texels;
					_tmp52_ = self->priv->_chans;
					_tmp53_ = self->priv->_width;
					_tmp54_ = y;
					_tmp55_ = data;
					_tmp56_ = stride;
					_tmp57_ = y;
					_tmp58_ = width;
					_tmp59_ = self->priv->_chans;
					memcpy (_tmp51_ + ((_tmp52_ * _tmp53_) * _tmp54_), _tmp55_ + (_tmp56_ * _tmp57_), (gsize) (_tmp58_ * _tmp59_));
				}
			}
		}
	}
	_tmp60_ = width;
	_tmp61_ = height;
	self->priv->_aspect = ((gfloat) _tmp60_) / ((gfloat) _tmp61_);
	_tmp62_ = width;
	_tmp63_ = self->priv->_width;
	self->priv->_scaleX = (GLfloat) (((gfloat) _tmp62_) / ((gfloat) _tmp63_));
	_tmp64_ = height;
	_tmp65_ = self->priv->_height;
	self->priv->_scaleY = (GLfloat) (((gfloat) _tmp64_) / ((gfloat) _tmp65_));
	_tmp67_ = self->priv->_scaleX;
	if (_tmp67_ == ((GLfloat) 1.0f)) {
		GLfloat _tmp68_;
		_tmp68_ = self->priv->_scaleY;
		_tmp66_ = _tmp68_ == ((GLfloat) 1.0f);
	} else {
		_tmp66_ = FALSE;
	}
	_tmp69_ = _tmp66_;
	if (_tmp69_) {
		self->priv->_scaleX = (GLfloat) 0.0f;
	}
}


static void _soy_textures_texture_texel_set (soytexturesTexture* self, soyatomsColor* color) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = self->priv->_chans;
	if (_tmp0_ == 1) {
		{
			GeeHashMap* _tmp1_;
			GeeSet* _tmp2_;
			GeeSet* _tmp3_;
			GeeSet* _tmp4_;
			GeeIterator* _tmp5_ = NULL;
			GeeIterator* _tmp6_;
			GeeIterator* _index_it;
			_tmp1_ = self->priv->_texel_objs;
			_tmp2_ = gee_abstract_map_get_keys ((GeeMap*) _tmp1_);
			_tmp3_ = _tmp2_;
			_tmp4_ = _tmp3_;
			_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
			_tmp6_ = _tmp5_;
			_g_object_unref0 (_tmp4_);
			_index_it = _tmp6_;
			while (TRUE) {
				GeeIterator* _tmp7_;
				gboolean _tmp8_ = FALSE;
				GeeIterator* _tmp9_;
				gpointer _tmp10_ = NULL;
				gint index;
				GeeHashMap* _tmp11_;
				gint _tmp12_;
				gpointer _tmp13_ = NULL;
				soyatomsColor* _tmp14_;
				_tmp7_ = _index_it;
				_tmp8_ = gee_iterator_next (_tmp7_);
				if (!_tmp8_) {
					break;
				}
				_tmp9_ = _index_it;
				_tmp10_ = gee_iterator_get (_tmp9_);
				index = (gint) ((gintptr) _tmp10_);
				_tmp11_ = self->priv->_texel_objs;
				_tmp12_ = index;
				_tmp13_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp11_, (gpointer) ((gintptr) _tmp12_));
				_tmp14_ = color;
				if (((soyatomsColor*) _tmp13_) == _tmp14_) {
					guchar* _tmp15_;
					gint _tmp16_;
					soyatomsColor* _tmp17_;
					guchar _tmp18_;
					guchar _tmp19_;
					guchar _tmp20_;
					_tmp15_ = self->texels;
					_tmp16_ = index;
					_tmp17_ = color;
					_tmp18_ = soy_atoms_color_get_luma (_tmp17_);
					_tmp19_ = _tmp18_;
					_tmp15_[_tmp16_] = _tmp19_;
					_tmp20_ = _tmp15_[_tmp16_];
				}
			}
			_g_object_unref0 (_index_it);
		}
	} else {
		gint _tmp21_;
		_tmp21_ = self->priv->_chans;
		if (_tmp21_ == 2) {
			{
				GeeHashMap* _tmp22_;
				GeeSet* _tmp23_;
				GeeSet* _tmp24_;
				GeeSet* _tmp25_;
				GeeIterator* _tmp26_ = NULL;
				GeeIterator* _tmp27_;
				GeeIterator* _index_it;
				_tmp22_ = self->priv->_texel_objs;
				_tmp23_ = gee_abstract_map_get_keys ((GeeMap*) _tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = _tmp24_;
				_tmp26_ = gee_iterable_iterator ((GeeIterable*) _tmp25_);
				_tmp27_ = _tmp26_;
				_g_object_unref0 (_tmp25_);
				_index_it = _tmp27_;
				while (TRUE) {
					GeeIterator* _tmp28_;
					gboolean _tmp29_ = FALSE;
					GeeIterator* _tmp30_;
					gpointer _tmp31_ = NULL;
					gint index;
					GeeHashMap* _tmp32_;
					gint _tmp33_;
					gpointer _tmp34_ = NULL;
					soyatomsColor* _tmp35_;
					_tmp28_ = _index_it;
					_tmp29_ = gee_iterator_next (_tmp28_);
					if (!_tmp29_) {
						break;
					}
					_tmp30_ = _index_it;
					_tmp31_ = gee_iterator_get (_tmp30_);
					index = (gint) ((gintptr) _tmp31_);
					_tmp32_ = self->priv->_texel_objs;
					_tmp33_ = index;
					_tmp34_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp32_, (gpointer) ((gintptr) _tmp33_));
					_tmp35_ = color;
					if (((soyatomsColor*) _tmp34_) == _tmp35_) {
						guchar* _tmp36_;
						gint _tmp37_;
						soyatomsColor* _tmp38_;
						guchar _tmp39_;
						guchar _tmp40_;
						guchar _tmp41_;
						guchar* _tmp42_;
						gint _tmp43_;
						soyatomsColor* _tmp44_;
						guchar _tmp45_;
						guchar _tmp46_;
						guchar _tmp47_;
						_tmp36_ = self->texels;
						_tmp37_ = index;
						_tmp38_ = color;
						_tmp39_ = soy_atoms_color_get_luma (_tmp38_);
						_tmp40_ = _tmp39_;
						_tmp36_[_tmp37_ * 2] = _tmp40_;
						_tmp41_ = _tmp36_[_tmp37_ * 2];
						_tmp42_ = self->texels;
						_tmp43_ = index;
						_tmp44_ = color;
						_tmp45_ = soy_atoms_color_get_alpha (_tmp44_);
						_tmp46_ = _tmp45_;
						_tmp42_[(_tmp43_ * 2) + 1] = _tmp46_;
						_tmp47_ = _tmp42_[(_tmp43_ * 2) + 1];
					}
				}
				_g_object_unref0 (_index_it);
			}
		} else {
			gint _tmp48_;
			_tmp48_ = self->priv->_chans;
			if (_tmp48_ == 3) {
				{
					GeeHashMap* _tmp49_;
					GeeSet* _tmp50_;
					GeeSet* _tmp51_;
					GeeSet* _tmp52_;
					GeeIterator* _tmp53_ = NULL;
					GeeIterator* _tmp54_;
					GeeIterator* _index_it;
					_tmp49_ = self->priv->_texel_objs;
					_tmp50_ = gee_abstract_map_get_keys ((GeeMap*) _tmp49_);
					_tmp51_ = _tmp50_;
					_tmp52_ = _tmp51_;
					_tmp53_ = gee_iterable_iterator ((GeeIterable*) _tmp52_);
					_tmp54_ = _tmp53_;
					_g_object_unref0 (_tmp52_);
					_index_it = _tmp54_;
					while (TRUE) {
						GeeIterator* _tmp55_;
						gboolean _tmp56_ = FALSE;
						GeeIterator* _tmp57_;
						gpointer _tmp58_ = NULL;
						gint index;
						GeeHashMap* _tmp59_;
						gint _tmp60_;
						gpointer _tmp61_ = NULL;
						soyatomsColor* _tmp62_;
						_tmp55_ = _index_it;
						_tmp56_ = gee_iterator_next (_tmp55_);
						if (!_tmp56_) {
							break;
						}
						_tmp57_ = _index_it;
						_tmp58_ = gee_iterator_get (_tmp57_);
						index = (gint) ((gintptr) _tmp58_);
						_tmp59_ = self->priv->_texel_objs;
						_tmp60_ = index;
						_tmp61_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp59_, (gpointer) ((gintptr) _tmp60_));
						_tmp62_ = color;
						if (((soyatomsColor*) _tmp61_) == _tmp62_) {
							guchar* _tmp63_;
							gint _tmp64_;
							soyatomsColor* _tmp65_;
							guchar _tmp66_;
							guchar _tmp67_;
							guchar _tmp68_;
							guchar* _tmp69_;
							gint _tmp70_;
							soyatomsColor* _tmp71_;
							guchar _tmp72_;
							guchar _tmp73_;
							guchar _tmp74_;
							guchar* _tmp75_;
							gint _tmp76_;
							soyatomsColor* _tmp77_;
							guchar _tmp78_;
							guchar _tmp79_;
							guchar _tmp80_;
							_tmp63_ = self->texels;
							_tmp64_ = index;
							_tmp65_ = color;
							_tmp66_ = soy_atoms_color_get_red (_tmp65_);
							_tmp67_ = _tmp66_;
							_tmp63_[_tmp64_ * 3] = _tmp67_;
							_tmp68_ = _tmp63_[_tmp64_ * 3];
							_tmp69_ = self->texels;
							_tmp70_ = index;
							_tmp71_ = color;
							_tmp72_ = soy_atoms_color_get_green (_tmp71_);
							_tmp73_ = _tmp72_;
							_tmp69_[(_tmp70_ * 3) + 1] = _tmp73_;
							_tmp74_ = _tmp69_[(_tmp70_ * 3) + 1];
							_tmp75_ = self->texels;
							_tmp76_ = index;
							_tmp77_ = color;
							_tmp78_ = soy_atoms_color_get_blue (_tmp77_);
							_tmp79_ = _tmp78_;
							_tmp75_[(_tmp76_ * 3) + 2] = _tmp79_;
							_tmp80_ = _tmp75_[(_tmp76_ * 3) + 2];
						}
					}
					_g_object_unref0 (_index_it);
				}
			} else {
				{
					GeeHashMap* _tmp81_;
					GeeSet* _tmp82_;
					GeeSet* _tmp83_;
					GeeSet* _tmp84_;
					GeeIterator* _tmp85_ = NULL;
					GeeIterator* _tmp86_;
					GeeIterator* _index_it;
					_tmp81_ = self->priv->_texel_objs;
					_tmp82_ = gee_abstract_map_get_keys ((GeeMap*) _tmp81_);
					_tmp83_ = _tmp82_;
					_tmp84_ = _tmp83_;
					_tmp85_ = gee_iterable_iterator ((GeeIterable*) _tmp84_);
					_tmp86_ = _tmp85_;
					_g_object_unref0 (_tmp84_);
					_index_it = _tmp86_;
					while (TRUE) {
						GeeIterator* _tmp87_;
						gboolean _tmp88_ = FALSE;
						GeeIterator* _tmp89_;
						gpointer _tmp90_ = NULL;
						gint index;
						GeeHashMap* _tmp91_;
						gint _tmp92_;
						gpointer _tmp93_ = NULL;
						soyatomsColor* _tmp94_;
						_tmp87_ = _index_it;
						_tmp88_ = gee_iterator_next (_tmp87_);
						if (!_tmp88_) {
							break;
						}
						_tmp89_ = _index_it;
						_tmp90_ = gee_iterator_get (_tmp89_);
						index = (gint) ((gintptr) _tmp90_);
						_tmp91_ = self->priv->_texel_objs;
						_tmp92_ = index;
						_tmp93_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp91_, (gpointer) ((gintptr) _tmp92_));
						_tmp94_ = color;
						if (((soyatomsColor*) _tmp93_) == _tmp94_) {
							guchar* _tmp95_;
							gint _tmp96_;
							soyatomsColor* _tmp97_;
							guchar _tmp98_;
							guchar _tmp99_;
							guchar _tmp100_;
							guchar* _tmp101_;
							gint _tmp102_;
							soyatomsColor* _tmp103_;
							guchar _tmp104_;
							guchar _tmp105_;
							guchar _tmp106_;
							guchar* _tmp107_;
							gint _tmp108_;
							soyatomsColor* _tmp109_;
							guchar _tmp110_;
							guchar _tmp111_;
							guchar _tmp112_;
							guchar* _tmp113_;
							gint _tmp114_;
							soyatomsColor* _tmp115_;
							guchar _tmp116_;
							guchar _tmp117_;
							guchar _tmp118_;
							_tmp95_ = self->texels;
							_tmp96_ = index;
							_tmp97_ = color;
							_tmp98_ = soy_atoms_color_get_red (_tmp97_);
							_tmp99_ = _tmp98_;
							_tmp95_[_tmp96_ * 4] = _tmp99_;
							_tmp100_ = _tmp95_[_tmp96_ * 4];
							_tmp101_ = self->texels;
							_tmp102_ = index;
							_tmp103_ = color;
							_tmp104_ = soy_atoms_color_get_green (_tmp103_);
							_tmp105_ = _tmp104_;
							_tmp101_[(_tmp102_ * 4) + 1] = _tmp105_;
							_tmp106_ = _tmp101_[(_tmp102_ * 4) + 1];
							_tmp107_ = self->texels;
							_tmp108_ = index;
							_tmp109_ = color;
							_tmp110_ = soy_atoms_color_get_blue (_tmp109_);
							_tmp111_ = _tmp110_;
							_tmp107_[(_tmp108_ * 4) + 2] = _tmp111_;
							_tmp112_ = _tmp107_[(_tmp108_ * 4) + 2];
							_tmp113_ = self->texels;
							_tmp114_ = index;
							_tmp115_ = color;
							_tmp116_ = soy_atoms_color_get_alpha (_tmp115_);
							_tmp117_ = _tmp116_;
							_tmp113_[(_tmp114_ * 4) + 3] = _tmp117_;
							_tmp118_ = _tmp113_[(_tmp114_ * 4) + 3];
						}
					}
					_g_object_unref0 (_index_it);
				}
			}
		}
	}
	g_mutex_lock (&self->priv->_mutex);
	self->priv->_updated = TRUE;
	g_mutex_unlock (&self->priv->_mutex);
}


static void _soy_textures_texture_texel_weak (soytexturesTexture* self, GObject* color) {
	GeeArrayList* _tmp0_;
	GeeArrayList* garbage;
	g_return_if_fail (self != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, NULL);
	garbage = _tmp0_;
	{
		GeeHashMap* _tmp1_;
		GeeSet* _tmp2_;
		GeeSet* _tmp3_;
		GeeSet* _tmp4_;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _tmp6_;
		GeeIterator* _index_it;
		_tmp1_ = self->priv->_texel_objs;
		_tmp2_ = gee_abstract_map_get_keys ((GeeMap*) _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp4_);
		_index_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_;
			gboolean _tmp8_ = FALSE;
			GeeIterator* _tmp9_;
			gpointer _tmp10_ = NULL;
			gint index;
			GeeHashMap* _tmp11_;
			gint _tmp12_;
			gpointer _tmp13_ = NULL;
			GObject* _tmp14_;
			_tmp7_ = _index_it;
			_tmp8_ = gee_iterator_next (_tmp7_);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = _index_it;
			_tmp10_ = gee_iterator_get (_tmp9_);
			index = (gint) ((gintptr) _tmp10_);
			_tmp11_ = self->priv->_texel_objs;
			_tmp12_ = index;
			_tmp13_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp11_, (gpointer) ((gintptr) _tmp12_));
			_tmp14_ = color;
			if (G_TYPE_CHECK_INSTANCE_CAST ((soyatomsColor*) _tmp13_, G_TYPE_OBJECT, GObject) == _tmp14_) {
				GeeArrayList* _tmp15_;
				gint _tmp16_;
				_tmp15_ = garbage;
				_tmp16_ = index;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, (gpointer) ((gintptr) _tmp16_));
			}
		}
		_g_object_unref0 (_index_it);
	}
	{
		GeeArrayList* _tmp17_;
		GeeArrayList* _tmp18_;
		GeeArrayList* _index_list;
		GeeArrayList* _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		gint _index_size;
		gint _index_index;
		_tmp17_ = garbage;
		_tmp18_ = _g_object_ref0 (_tmp17_);
		_index_list = _tmp18_;
		_tmp19_ = _index_list;
		_tmp20_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp19_);
		_tmp21_ = _tmp20_;
		_index_size = _tmp21_;
		_index_index = -1;
		while (TRUE) {
			gint _tmp22_;
			gint _tmp23_;
			gint _tmp24_;
			GeeArrayList* _tmp25_;
			gint _tmp26_;
			gpointer _tmp27_ = NULL;
			gint index;
			GeeHashMap* _tmp28_;
			gint _tmp29_;
			_tmp22_ = _index_index;
			_index_index = _tmp22_ + 1;
			_tmp23_ = _index_index;
			_tmp24_ = _index_size;
			if (!(_tmp23_ < _tmp24_)) {
				break;
			}
			_tmp25_ = _index_list;
			_tmp26_ = _index_index;
			_tmp27_ = gee_abstract_list_get ((GeeAbstractList*) _tmp25_, _tmp26_);
			index = (gint) ((gintptr) _tmp27_);
			_tmp28_ = self->priv->_texel_objs;
			_tmp29_ = index;
			gee_abstract_map_unset ((GeeAbstractMap*) _tmp28_, (gpointer) ((gintptr) _tmp29_), NULL);
		}
		_g_object_unref0 (_index_list);
	}
	_g_object_unref0 (garbage);
}


void soy_textures_texture_resize (soytexturesTexture* self, gint c, gint x, gint y) {
	gint size = 0;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp37_;
	gint _tmp38_;
	gint _tmp39_;
	g_return_if_fail (self != NULL);
	g_mutex_lock (&self->priv->_mutex);
	_tmp0_ = c;
	_tmp1_ = x;
	_tmp2_ = y;
	size = (_tmp0_ * _tmp1_) * _tmp2_;
	_tmp3_ = size;
	if (_tmp3_ == 0) {
		GLsizei _tmp4_;
		_tmp4_ = self->priv->_width;
		if (_tmp4_ != ((GLsizei) 0)) {
			guchar* _tmp5_;
			_tmp5_ = self->texels;
			g_free (_tmp5_);
			self->texels = NULL;
		}
	} else {
		GLsizei _tmp6_;
		_tmp6_ = self->priv->_width;
		if (_tmp6_ != ((GLsizei) 0)) {
			gboolean _tmp7_ = FALSE;
			gboolean _tmp8_ = FALSE;
			gint _tmp9_;
			gint _tmp10_;
			gboolean _tmp13_;
			gboolean _tmp16_;
			_tmp9_ = self->priv->_chans;
			_tmp10_ = c;
			if (_tmp9_ != _tmp10_) {
				_tmp8_ = TRUE;
			} else {
				GLsizei _tmp11_;
				gint _tmp12_;
				_tmp11_ = self->priv->_width;
				_tmp12_ = x;
				_tmp8_ = _tmp11_ != ((GLsizei) _tmp12_);
			}
			_tmp13_ = _tmp8_;
			if (_tmp13_) {
				_tmp7_ = TRUE;
			} else {
				GLsizei _tmp14_;
				gint _tmp15_;
				_tmp14_ = self->priv->_height;
				_tmp15_ = y;
				_tmp7_ = _tmp14_ != ((GLsizei) _tmp15_);
			}
			_tmp16_ = _tmp7_;
			if (_tmp16_) {
				gint _tmp17_;
				void* _tmp18_ = NULL;
				guchar* temptexels;
				guchar* _tmp19_;
				guchar* origin;
				gint _tmp20_;
				GLsizei _tmp21_;
				GLsizei _tmp22_;
				gint oldSize;
				guchar* _tmp33_;
				guchar* _tmp34_;
				_tmp17_ = size;
				_tmp18_ = g_malloc ((gsize) _tmp17_);
				temptexels = _tmp18_;
				_tmp19_ = temptexels;
				origin = _tmp19_;
				_tmp20_ = self->priv->_chans;
				_tmp21_ = self->priv->_width;
				_tmp22_ = self->priv->_height;
				oldSize = (_tmp20_ * _tmp21_) * _tmp22_;
				{
					gint index;
					index = 0;
					{
						gboolean _tmp23_;
						_tmp23_ = TRUE;
						while (TRUE) {
							gboolean _tmp24_;
							gint _tmp26_;
							guchar* _tmp27_;
							gint _tmp28_;
							guchar* _tmp29_;
							gint _tmp30_;
							guchar _tmp31_;
							guchar _tmp32_;
							_tmp24_ = _tmp23_;
							if (!_tmp24_) {
								gint _tmp25_;
								_tmp25_ = index;
								index = _tmp25_ + 1;
							}
							_tmp23_ = FALSE;
							_tmp26_ = oldSize;
							if (!(index <= (_tmp26_ - 1))) {
								break;
							}
							_tmp27_ = temptexels;
							_tmp28_ = index;
							_tmp29_ = self->texels;
							_tmp30_ = index;
							_tmp31_ = _tmp29_[_tmp30_];
							_tmp27_[_tmp28_] = _tmp31_;
							_tmp32_ = _tmp27_[_tmp28_];
						}
					}
				}
				_tmp33_ = self->texels;
				g_free (_tmp33_);
				_tmp34_ = origin;
				self->texels = _tmp34_;
			}
		} else {
			gint _tmp35_;
			void* _tmp36_ = NULL;
			_tmp35_ = size;
			_tmp36_ = g_malloc0 ((gsize) _tmp35_);
			self->texels = _tmp36_;
		}
	}
	_tmp37_ = c;
	self->priv->_chans = _tmp37_;
	_tmp38_ = x;
	self->priv->_width = (GLsizei) _tmp38_;
	_tmp39_ = y;
	self->priv->_height = (GLsizei) _tmp39_;
	self->priv->_updated = TRUE;
	g_mutex_unlock (&self->priv->_mutex);
}


gint soy_textures_texture_squareup (gint _v) {
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	_tmp0_ = _v;
	_v = _tmp0_ - 1;
	_tmp1_ = _v;
	_tmp2_ = _v;
	_v = _tmp1_ | (_tmp2_ >> 1);
	_tmp3_ = _v;
	_tmp4_ = _v;
	_v = _tmp3_ | (_tmp4_ >> 2);
	_tmp5_ = _v;
	_tmp6_ = _v;
	_v = _tmp5_ | (_tmp6_ >> 4);
	_tmp7_ = _v;
	_tmp8_ = _v;
	_v = _tmp7_ | (_tmp8_ >> 8);
	_tmp9_ = _v;
	_tmp10_ = _v;
	_v = _tmp9_ | (_tmp10_ >> 16);
	_tmp11_ = _v;
	result = _tmp11_ + 1;
	return result;
}


inline void soy_textures_texture_update (soytexturesTexture* self, GLenum target) {
	GLenum _tmp0_;
	GLenum* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_;
	GLenum _tmp3_;
	GLsizei _tmp4_;
	GLsizei _tmp5_;
	GLenum* _tmp6_;
	gint _tmp6__length1;
	gint _tmp7_;
	GLenum _tmp8_;
	guchar* _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp0_ = target;
	_tmp1_ = soy_textures_texture__formats;
	_tmp1__length1 = soy_textures_texture__formats_length1;
	_tmp2_ = self->priv->_chans;
	_tmp3_ = _tmp1_[_tmp2_];
	_tmp4_ = self->priv->_width;
	_tmp5_ = self->priv->_height;
	_tmp6_ = soy_textures_texture__formats;
	_tmp6__length1 = soy_textures_texture__formats_length1;
	_tmp7_ = self->priv->_chans;
	_tmp8_ = _tmp6_[_tmp7_];
	_tmp9_ = self->texels;
	glTexImage2D (_tmp0_, (GLint) 0, (GLint) _tmp3_, _tmp4_, _tmp5_, (GLint) 0, _tmp8_, GL_UNSIGNED_BYTE, (GLvoid*) _tmp9_);
}


static void soy_textures_texture_real_enable (soytexturesTexture* self) {
	gint _i = 0;
	gfloat* _tmp0_ = NULL;
	gfloat* _anim;
	gint _anim_length1;
	gint __anim_size_;
	guchar* _tmp1_;
	GLuint _tmp6_;
	gboolean _tmp11_;
	gint _tmp12_;
	GLfloat _tmp42_;
	_tmp0_ = g_new0 (gfloat, 3);
	_anim = _tmp0_;
	_anim_length1 = 3;
	__anim_size_ = _anim_length1;
	_tmp1_ = self->texels;
	if (_tmp1_ == NULL) {
		GLuint _tmp2_;
		_tmp2_ = self->priv->_textureID;
		if (_tmp2_ != ((GLuint) 0)) {
			GLuint _tmp3_;
			GLuint* _tmp4_ = NULL;
			GLuint* _tmp5_;
			gint _tmp5__length1;
			_tmp3_ = self->priv->_textureID;
			_tmp4_ = g_new0 (GLuint, 1);
			_tmp4_[0] = _tmp3_;
			_tmp5_ = _tmp4_;
			_tmp5__length1 = 1;
			glDeleteTextures ((GLsizei) 1, _tmp5_);
			_tmp5_ = (g_free (_tmp5_), NULL);
		}
		_anim = (g_free (_anim), NULL);
		return;
	}
	g_mutex_lock (&self->priv->_mutex);
	glEnable (GL_TEXTURE_2D);
	_tmp6_ = self->priv->_textureID;
	if (_tmp6_ == ((GLuint) 0)) {
		GLuint _tmp7_ = 0U;
		GLuint _tmp8_;
		gboolean _tmp9_;
		glGenTextures ((GLsizei) 1, &_tmp7_);
		self->priv->_textureID = _tmp7_;
		_tmp8_ = self->priv->_textureID;
		glBindTexture (GL_TEXTURE_2D, _tmp8_);
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLint) GL_LINEAR);
		_tmp9_ = self->priv->_smooth;
		if (_tmp9_) {
			glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLint) GL_LINEAR);
		} else {
			glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLint) GL_NEAREST);
		}
		self->priv->_updated = TRUE;
	} else {
		GLuint _tmp10_;
		_tmp10_ = self->priv->_textureID;
		glBindTexture (GL_TEXTURE_2D, _tmp10_);
	}
	_tmp11_ = self->priv->_updated;
	if (_tmp11_) {
		soy_textures_texture_update (self, GL_TEXTURE_2D);
		self->priv->_updated = FALSE;
	}
	_tmp12_ = self->priv->_isAnimated;
	if (_tmp12_ == 1) {
		GTimeVal tv = {0};
		GTimeVal _tmp13_;
		glong _tmp14_;
		GTimeVal _tmp15_;
		glong _tmp16_;
		gfloat _it;
		gfloat* _tmp36_;
		gint _tmp36__length1;
		gfloat _tmp37_;
		gfloat* _tmp38_;
		gint _tmp38__length1;
		gfloat _tmp39_;
		gfloat* _tmp40_;
		gint _tmp40__length1;
		gfloat _tmp41_;
		g_get_current_time (&tv);
		_tmp13_ = tv;
		_tmp14_ = _tmp13_.tv_sec;
		_tmp15_ = tv;
		_tmp16_ = _tmp15_.tv_usec;
		_it = ((gfloat) _tmp14_) + (((gfloat) _tmp16_) / 1000000.0f);
		{
			gboolean _tmp17_;
			_i = 0;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gfloat* _tmp20_;
				gint _tmp20__length1;
				gint _tmp21_;
				gfloat _tmp22_;
				GLfloat* _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				GLfloat _tmp25_;
				gfloat _tmp26_;
				gfloat* _tmp27_;
				gint _tmp27__length1;
				gint _tmp28_;
				gfloat* _tmp29_;
				gint _tmp29__length1;
				gint _tmp30_;
				gfloat _tmp31_;
				gfloat* _tmp32_;
				gint _tmp32__length1;
				gint _tmp33_;
				gfloat _tmp34_;
				gfloat _tmp35_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = _i;
					_i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				if (!(_i <= 3)) {
					break;
				}
				_tmp20_ = _anim;
				_tmp20__length1 = _anim_length1;
				_tmp21_ = _i;
				_tmp22_ = _it;
				_tmp23_ = self->priv->_animate;
				_tmp23__length1 = self->priv->_animate_length1;
				_tmp24_ = _i;
				_tmp25_ = _tmp23_[_tmp24_];
				_tmp20_[_tmp21_] = _tmp22_ * _tmp25_;
				_tmp26_ = _tmp20_[_tmp21_];
				_tmp27_ = _anim;
				_tmp27__length1 = _anim_length1;
				_tmp28_ = _i;
				_tmp29_ = _anim;
				_tmp29__length1 = _anim_length1;
				_tmp30_ = _i;
				_tmp31_ = _tmp29_[_tmp30_];
				_tmp32_ = _anim;
				_tmp32__length1 = _anim_length1;
				_tmp33_ = _i;
				_tmp34_ = _tmp32_[_tmp33_];
				_tmp27_[_tmp28_] = _tmp31_ - _tmp34_;
				_tmp35_ = _tmp27_[_tmp28_];
			}
		}
		glMatrixMode (GL_TEXTURE);
		_tmp36_ = _anim;
		_tmp36__length1 = _anim_length1;
		_tmp37_ = _tmp36_[0];
		_tmp38_ = _anim;
		_tmp38__length1 = _anim_length1;
		_tmp39_ = _tmp38_[1];
		_tmp40_ = _anim;
		_tmp40__length1 = _anim_length1;
		_tmp41_ = _tmp40_[2];
		glTranslatef ((GLfloat) ((gfloat) _tmp37_), (GLfloat) ((gfloat) _tmp39_), (GLfloat) ((gfloat) _tmp41_));
	}
	_tmp42_ = self->priv->_scaleX;
	if (_tmp42_ != ((GLfloat) 0)) {
		GLfloat _tmp43_;
		GLfloat _tmp44_;
		glMatrixMode (GL_TEXTURE);
		_tmp43_ = self->priv->_scaleX;
		_tmp44_ = self->priv->_scaleY;
		glScalef (_tmp43_, _tmp44_, (GLfloat) 1);
	}
	_anim = (g_free (_anim), NULL);
}


void soy_textures_texture_enable (soytexturesTexture* self) {
	g_return_if_fail (self != NULL);
	SOY_TEXTURES_TEXTURE_GET_CLASS (self)->enable (self);
}


static void soy_textures_texture_real_disable (soytexturesTexture* self) {
	guchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_;
	gboolean _tmp4_;
	_tmp0_ = self->texels;
	if (_tmp0_ == NULL) {
		return;
	}
	glDisable (GL_TEXTURE_2D);
	_tmp2_ = self->priv->_isAnimated;
	if (_tmp2_ != 0) {
		_tmp1_ = TRUE;
	} else {
		GLfloat _tmp3_;
		_tmp3_ = self->priv->_scaleX;
		_tmp1_ = _tmp3_ != ((GLfloat) 0);
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		glMatrixMode (GL_TEXTURE);
		glLoadIdentity ();
	}
	g_mutex_unlock (&self->priv->_mutex);
}


void soy_textures_texture_disable (soytexturesTexture* self) {
	g_return_if_fail (self != NULL);
	SOY_TEXTURES_TEXTURE_GET_CLASS (self)->disable (self);
}


static guchar* _vala_array_dup4 (guchar* self, int length) {
	return g_memdup (self, length * sizeof (guchar));
}


void soy_textures_texture_load (soytexturesTexture* self, void* _vdata, gint _size) {
	guchar* _data = NULL;
	gint _data_length1 = 0;
	gint __data_size_ = 0;
	void* _tmp0_;
	guchar* _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vdata;
	_tmp1_ = (((guchar*) _tmp0_) != NULL) ? _vala_array_dup4 ((guchar*) _tmp0_, -1) : ((gpointer) ((guchar*) _tmp0_));
	_tmp1__length1 = -1;
	_data = (g_free (_data), NULL);
	_data = _tmp1_;
	_data_length1 = _tmp1__length1;
	__data_size_ = _data_length1;
	_data = (g_free (_data), NULL);
}


GLfloat* soy_textures_texture_get_animate (soytexturesTexture* self, int* result_length1) {
	GLfloat* result;
	GLfloat* _tmp0_;
	gint _tmp0__length1;
	GLfloat* _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_animate;
	_tmp0__length1 = self->priv->_animate_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


gfloat soy_textures_texture_get_aspect (soytexturesTexture* self) {
	gfloat result;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->priv->_aspect;
	result = _tmp0_;
	return result;
}


gint soy_textures_texture_get_channels (soytexturesTexture* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_chans;
	result = _tmp0_;
	return result;
}


void soy_textures_texture_set_channels (soytexturesTexture* self, gint value) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp3_;
	gint _tmp4_;
	GLsizei _tmp5_;
	GLsizei _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp1_ = value;
	if (_tmp1_ < 1) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = value;
		_tmp0_ = _tmp2_ > 4;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		return;
	}
	_tmp4_ = value;
	_tmp5_ = self->priv->_width;
	_tmp6_ = self->priv->_height;
	soy_textures_texture_resize (self, _tmp4_, (gint) _tmp5_, (gint) _tmp6_);
	g_object_notify ((GObject *) self, "channels");
}


static void __soy_textures_texture_size_set_soy_atoms_size_on_set (soyatomsSize* _sender, soyatomsSize* size, gpointer self) {
	_soy_textures_texture_size_set (self, size);
}


static void __soy_textures_texture_size_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_textures_texture_size_weak (self, object);
}


soyatomsSize* soy_textures_texture_get_size (soytexturesTexture* self) {
	soyatomsSize* result;
	soyatomsSize* _tmp0_;
	soyatomsSize* _tmp1_;
	soyatomsSize* value;
	soyatomsSize* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_size_obj;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	value = _tmp1_;
	_tmp2_ = value;
	if (_tmp2_ == NULL) {
		GLsizei _tmp3_;
		GLsizei _tmp4_;
		soyatomsSize* _tmp5_;
		soyatomsSize* _tmp6_;
		soyatomsSize* _tmp7_;
		soyatomsSize* _tmp8_;
		_tmp3_ = self->priv->_width;
		_tmp4_ = self->priv->_height;
		_tmp5_ = soy_atoms_size_new ((gfloat) _tmp3_, (gfloat) _tmp4_, 0.0f);
		_g_object_unref0 (value);
		value = _tmp5_;
		_tmp6_ = value;
		g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_textures_texture_size_set_soy_atoms_size_on_set, self, 0);
		_tmp7_ = value;
		g_object_weak_ref ((GObject*) _tmp7_, __soy_textures_texture_size_weak_gweak_notify, self);
		_tmp8_ = value;
		self->priv->_size_obj = _tmp8_;
	}
	result = value;
	return result;
}


void soy_textures_texture_set_size (soytexturesTexture* self, soyatomsSize* value) {
	soyatomsSize* _tmp0_;
	soyatomsSize* _tmp1_;
	soyatomsSize* _tmp5_;
	soyatomsSize* _tmp6_;
	soyatomsSize* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_soy_textures_texture_size_set (self, _tmp0_);
	_tmp1_ = self->priv->_size_obj;
	if (_tmp1_ != NULL) {
		soyatomsSize* _tmp2_;
		guint _tmp3_ = 0U;
		soyatomsSize* _tmp4_;
		_tmp2_ = self->priv->_size_obj;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_SIZE, &_tmp3_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) __soy_textures_texture_size_set_soy_atoms_size_on_set, self);
		_tmp4_ = self->priv->_size_obj;
		g_object_weak_unref ((GObject*) _tmp4_, __soy_textures_texture_size_weak_gweak_notify, self);
	}
	_tmp5_ = value;
	self->priv->_size_obj = _tmp5_;
	_tmp6_ = value;
	g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_textures_texture_size_set_soy_atoms_size_on_set, self, 0);
	_tmp7_ = value;
	g_object_weak_ref ((GObject*) _tmp7_, __soy_textures_texture_size_weak_gweak_notify, self);
	g_object_notify ((GObject *) self, "size");
}


gboolean soy_textures_texture_get_smooth (soytexturesTexture* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_smooth;
	result = _tmp0_;
	return result;
}


void soy_textures_texture_set_smooth (soytexturesTexture* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_smooth = _tmp0_;
	self->priv->_updated = TRUE;
	g_object_notify ((GObject *) self, "smooth");
}


static GObject * soy_textures_texture_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	soytexturesTexture * self;
	GeeHashMap* _tmp0_;
	GLfloat* _tmp1_ = NULL;
	parent_class = G_OBJECT_CLASS (soy_textures_texture_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	_tmp0_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, SOY_ATOMS_TYPE_COLOR, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_texel_objs);
	self->priv->_texel_objs = _tmp0_;
	_tmp1_ = g_new0 (GLfloat, 3);
	self->priv->_animate = (g_free (self->priv->_animate), NULL);
	self->priv->_animate = _tmp1_;
	self->priv->_animate_length1 = 3;
	self->priv->__animate_size_ = self->priv->_animate_length1;
	_vala_clear_GMutex (&self->priv->_mutex);
	g_mutex_init (&self->priv->_mutex);
	self->priv->_scaleX = (GLfloat) 0.0f;
	self->priv->_smooth = TRUE;
	return obj;
}


static void soy_textures_texture_class_init (soytexturesTextureClass * klass) {
	GLenum* _tmp0_ = NULL;
	soy_textures_texture_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (soytexturesTexturePrivate));
	SOY_TEXTURES_TEXTURE_CLASS (klass)->enable = soy_textures_texture_real_enable;
	SOY_TEXTURES_TEXTURE_CLASS (klass)->disable = soy_textures_texture_real_disable;
	G_OBJECT_CLASS (klass)->get_property = _vala_soy_textures_texture_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_soy_textures_texture_set_property;
	G_OBJECT_CLASS (klass)->constructor = soy_textures_texture_constructor;
	G_OBJECT_CLASS (klass)->finalize = soy_textures_texture_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_ASPECT, g_param_spec_float ("aspect", "aspect", "aspect", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_CHANNELS, g_param_spec_int ("channels", "channels", "channels", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_SIZE, g_param_spec_object ("size", "size", "size", SOY_ATOMS_TYPE_SIZE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_SMOOTH, g_param_spec_boolean ("smooth", "smooth", "smooth", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	_tmp0_ = g_new0 (GLenum, 5);
	_tmp0_[0] = (GLenum) 0;
	_tmp0_[1] = GL_LUMINANCE;
	_tmp0_[2] = GL_LUMINANCE_ALPHA;
	_tmp0_[3] = GL_RGB;
	_tmp0_[4] = GL_RGBA;
	soy_textures_texture__formats = _tmp0_;
	soy_textures_texture__formats_length1 = 5;
}


static void soy_textures_texture_instance_init (soytexturesTexture * self) {
	self->priv = SOY_TEXTURES_TEXTURE_GET_PRIVATE (self);
}


static void soy_textures_texture_finalize (GObject* obj) {
	soytexturesTexture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	_g_object_unref0 (self->priv->_texel_objs);
	_vala_clear_GMutex (&self->priv->_mutex);
	self->priv->_animate = (g_free (self->priv->_animate), NULL);
	G_OBJECT_CLASS (soy_textures_texture_parent_class)->finalize (obj);
}


GType soy_textures_texture_get_type (void) {
	static volatile gsize soy_textures_texture_type_id__volatile = 0;
	if (g_once_init_enter (&soy_textures_texture_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (soytexturesTextureClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) soy_textures_texture_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (soytexturesTexture), 0, (GInstanceInitFunc) soy_textures_texture_instance_init, NULL };
		GType soy_textures_texture_type_id;
		soy_textures_texture_type_id = g_type_register_static (G_TYPE_OBJECT, "soytexturesTexture", &g_define_type_info, 0);
		g_once_init_leave (&soy_textures_texture_type_id__volatile, soy_textures_texture_type_id);
	}
	return soy_textures_texture_type_id__volatile;
}


static void _vala_soy_textures_texture_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	soytexturesTexture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	switch (property_id) {
		case SOY_TEXTURES_TEXTURE_ASPECT:
		g_value_set_float (value, soy_textures_texture_get_aspect (self));
		break;
		case SOY_TEXTURES_TEXTURE_CHANNELS:
		g_value_set_int (value, soy_textures_texture_get_channels (self));
		break;
		case SOY_TEXTURES_TEXTURE_SIZE:
		g_value_take_object (value, soy_textures_texture_get_size (self));
		break;
		case SOY_TEXTURES_TEXTURE_SMOOTH:
		g_value_set_boolean (value, soy_textures_texture_get_smooth (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_soy_textures_texture_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	soytexturesTexture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	switch (property_id) {
		case SOY_TEXTURES_TEXTURE_CHANNELS:
		soy_textures_texture_set_channels (self, g_value_get_int (value));
		break;
		case SOY_TEXTURES_TEXTURE_SIZE:
		soy_textures_texture_set_size (self, g_value_get_object (value));
		break;
		case SOY_TEXTURES_TEXTURE_SMOOTH:
		soy_textures_texture_set_smooth (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_clear_GMutex (GMutex * mutex) {
	GMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GMutex))) {
		g_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GMutex));
	}
}


static void _vala_clear_GRecMutex (GRecMutex * mutex) {
	GRecMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRecMutex))) {
		g_rec_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GRecMutex));
	}
}


static void _vala_clear_GRWLock (GRWLock * mutex) {
	GRWLock zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRWLock))) {
		g_rw_lock_clear (mutex);
		memset (mutex, 0, sizeof (GRWLock));
	}
}


static void _vala_clear_GCond (GCond * mutex) {
	GCond zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GCond))) {
		g_cond_clear (mutex);
		memset (mutex, 0, sizeof (GCond));
	}
}



